# JavaScript基础

## 简介

### -01. JavaScript历史

布兰登艾奇（Brendan Eich， 1961年～）。 神奇的大哥在1995年利用10天完成JavaScript设计。 网景公司最初命名为LiveScript ，后来在与Sun合作之后将其改名为JavaScript.

### -02. JavaScript是什么

lavaScript是世界上最流行的语言之一，是一种运行在客户端的脚本语言（Script是脚本的意思）脚本语言：不需要编译，运行过程中由js解释器（js引擎）逐行来进行解释并执行。 现在也可以基于Nodejs技术进行服务器端编程

### -03. JavaScript的作用

- 表单动态校验（密码强度检测） （ JS产生最初的目的）
- 网页特效
- 服务端开发（Node.js）
- 桌面程序（Electron）
- App(Cordova)
- 控制硬件—物联网（Ruff游戏F发(cocos2d-js)

### -04. 浏览器执行JS简介

浏览器分成两部分：**渲染引擎和JS引擎**

- 渲染引擎：用来解析HTML与CSS ，俗称内核，比如chrome浏览器的blink ，老版本的webkit
- JS引擎：也称为JS解释器。用来读取网页中的JavaScript代码，对其处理后运行，比如chrome浏览器的V8

> 浏览器本身并不会执行JS代码，而是通过内置JavaScript引擎（解释器）来执行JS代码。JS引擎执行代码时逐行解释每一句源码（转换为机器语言） ，然后由计算机去执行，所以JavaScript语言归为脚本语言，会逐行解释执行。

### -05. JS三大组成

- ECMAScript
- DOM
- BOM

#### (1) ECMAScript

ECMAScript是由ECMA国际（原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广 泛，它往往被称为JavaScript或JScript ，但实际上后两者是ECMAScript语言的实现和扩展。

ECMAScript

- lavaScript 网景公司
- Jscript 微软公司

ECMAScript ： **ECMAScript规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。**

#### (2) DOM—文档对象模型

文档对象模型（Document Object Model ，简称DOM ） ，是W3C组织推荐的处理可扩展标记语言的标准编程接口通过DOM提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）。

#### (3) BOM—浏览器对象模型

浏览器对象模型 （Browser Object Model ，简称BOM）是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。

### -06. JS 初体验

JS有3种书写位置，分别为行内、内嵌和外部

1. 行内式JS

   ```html
   <input type="button" value="click" onclick="alert('Hello, world!')">
   ```

   - 可以将单行或少量JS代码写在HTML标签的事件属性中（以on开头的属性） ，如： onclick
   - 注意单双引号的使用：在HEML中我们推荐使用双引号，JS中我们推荐使用单引号。
   - 可读性差，在html中编写JS大量代码时，不方便阅读；引号易错，引号多层嵌套匹配时，非常容易弄混；
   - 特殊情况下使用

2. 内嵌式

   ```html
   <script>
   alert("Hello world!");
   </script>
   ```

   学习时常用。

3. 外部JS文件

```html
    <script src="newFile.js"></script>
```

- 利于HTML页面代码结构化，把大段JS代码独立到HTML页面之外，既美观，也方便文件级别的复用
- **引用外部JS文件的script标签中间不可写代码**
- 适合于JS代码量比较大的情况

### -07. JS 注释

- 单行注释：

  ```js
  // 单行注释 Ctrl + /
  ```

- 多行注释：

  ```js
  /*
  多行注释 shift + alt + A
  */
  ```

### -08. JS输入输出语句

1. 输入框

`prompt` 方法返回一个 `string` 类型。

```js
 prompt('请输入你的名字：');
```

1. 警示框

```js
alert('你好');
```

1. 控制台打印

```js
console.log('我是程序员能看到的。');
```

## 变量

### -01. 变量的实质

变量是程序在内存中申请的一块用来存放数据的空间。

### -02. 变量的声明

1. 声明变量
2. 赋值

#### (1) 声明变量

```js
// 声明一个叫age的变量
var age;
let name;
const PI = 3.14;
```

- `var` 是一个JS关键字，用来声明变量（variable变量的意思），使用该关键字声明变量后，计算机会自动为变量分配内存空间，不需要程序员管
- `age` 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间

### -03. 变量的初始化

```js
var age = 18;
```

初始化：声明并赋值

### -04. 更新赋值

一个变量可以被重复赋值，变量值也会更新。

```js
var age = 18;
age = 81;
```

### -05. 同时声明多个变量

```js
var age = 18,
    url = 'https://mphy.top',
    myname = 'MurphyChen'
```

### -06. 声明不赋值

```js
var sex;
console.log(sex);
// undefined
console.log(aaa);
```

### -07. 直接输出

```js
console.log(tel); // 报错
```

### -08. 不声明直接赋值

```js
qq = 12345;
console.log(qq); // 12345 全局变量
```

### -09. 命名规范

- 由字母（A—Za—z）、数字（0—9）、下划线（_）、美元符号（$）组成，如： usrAge， num01， name
- 严格区分大小写。`var app`；和`var App`；是两个变量
- 不能以数字开头。18age是错误的
- 不能是关键字、保留字。例如： `var`，` for`，` while`
- 变量名必须有意义。MMD BBD nl— age
- 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。myFirstName推荐翻译网站：有道爱词霸
- 尽量不要使用 `name` 作为变量名

## 数据类型

### -01. 数据类型概述

#### (1) 为什么需要数据类型

在计算机中，不同的数据所需占用的存储空间是不同的，为了便于把数据分成所需内存大小不同的数据，充分利用存储空间，于是定义了不同的数据类型。

简单来说，数据类型就是数据的类别型号。比如姓名“张三” ，年龄18，这些数据的类型是不一样的。

#### (2) 变量的数据类型

变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。**JavaScript是一种弱类型或者说动态语言**。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。

```js
var age = 10;//这是一个数字型
var arerouok = 的； //这是一个字符串
```

在代码运行时，变量的数据类型是由JS引擎根据=右边变量值的数据类型来判断的，运行完毕之后，变量就确定了数据类型 JavaScript拥有动态类型，同时也意味着相同的变量可用作不同的类型：

```js
var x = 6; // x为数字
var x = "Bill"; // x为字符串
```

### -02. 简单数据类型

JavaScript中的简单数据类型（基本数据类型）及其说明如下：

| 简单数据类型 | 说明                                                   | 默认值      |
| ------------ | ------------------------------------------------------ | ----------- |
| Number       | 数字型，包含整值和浮点值，如21、0.21                   | `0`         |
| Boolean      | 布尔值类型，如true、 false，等价于1和0                 | `false`     |
| String       | 字符串类型，如“张三”注意js 里面，字符串都带引号        | `""`        |
| Undefined    | `var a;` 声明了变量a但是没有给值，此时a =undefinedNull | `undefined` |
| Null         | `var a = null;` 声明了变量a为空值                      | `null`      |

#### (1) 数字型 Number

##### 1. 数字型进制

常见：二进制、八进制、十进制、十六进制

- `0123`: `0` 开头表示八进制
- `0b11`: `0b` 开头表示二进制
- `0x11`: `0x` 开头表示十六进制
- 直接打印出来会转化为十进制

##### 2. 数字型范围

```js
console.log(Number.MAX_VALUE);
console.log(Number.MIN_VALUE);
```

##### 3. 特殊值

```js
console.log(Infinity);
console.log(-Infinity);
console.log(NaN);
```

- `Infinity`：无穷大
- `-Infinity`：无穷小
- `NaN`：Not a number，代表一个非数值。

##### 4. isNaN()

`isNaN` 方法用来判断一个变量和或者一个值是数字类型，若不是数字类型则返回 `true`；否则返回 `false`。

#### (2)字符串型 String

##### 1. 定义

字符长型可以是引号中的任意文本，其语法为双引号 `""` 和单引号 `''`。

##### 2. 字符串引号嵌套

JS可以用单引号嵌套双引号，或者用双引号嵌套单引号（外双内单，外单内双）

```js
var strmsg= '我是"高帅富"程序员';
var strmsg= "我是'高帅富'程序员";
```

##### 3. 字符串转义符

类似HTML里面的特殊字符，字符串中也有特殊字符，我们称之为转义符转义符都是`\`开头的，常用的转义符及其说明如下：

| 转义符 | 解释说明                    |
| ------ | --------------------------- |
| `\n`   | 换行符， n是 newline 的意思 |
| `\\`   | \                           |
| `\'`   | 单引号'                     |
| `\"`   | 双引号"                     |
| `\t`   | tab 缩进                    |
| `\b`   | 空格，b 是 blank 的意思     |

##### 4. 获取字符串长度 length

```js
var str = 'hello';
console.log(str.length);
```

##### 5. 字符串拼接

多个字符串之间可以使用+进行拼接，其拼接方式为 **字符串 + 任何类型 = 拼接之后的新字符串** 拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串。

##### 6. 字符串拼接加强

将字符串和变量相加，以后要更新最终的结果字符串，只需更新变量的值。

#### (3) 布尔型 Boolean

- 布尔型有两个值，`true` 和 `false`
- 布尔型（`true`，`false`）在参与加法时当作 `1` 和 `0` 使用

```js
console.log(true + 1); // 2
console.log(false + 1); // 1
```

#### (4) Undefined

```js
console.log(undefined + 1); // NaN
console.log(undefined + NaN); // NaN
console.log(undefined + true); // NaN
console.log(undefined + 'aaa'); // undefinedaaa
console.log(undefined + undefined); // NaN 
```

#### (5) 空值 Null

```js
console.log(null + 1); // 1
console.log(null + undefined); // NaN
console.log(null + NaN); // NaN
console.log(null + true); // 1
console.log(null + 'aaa'); // nullaaa
console.log(null + null); // 0
```

### -03. 获取变量数据类型

#### (1) typeof 获取变量数据类型

`typeof variable` （`typeof(variable)`） 返回一个字符串，值为该变量的数据类型。

```js
console.log(typeof 1); // number
console.log(typeof false); // boolean
console.log(typeof 'aaa');    // string
console.log(typeof undefined);// undefined
console.log(typeof NaN); // number
console.log(typeof Infinity); // number
console.log(typeof null); // object
console.log(typeof typeof 1); // string
```

#### (2)字面量

字面量是在源代码中一个固定的表示法，通俗来说，就是字面量如何表达这个值。

- 数字字面量：`1`、`0`
- 字符串字面量：`mphy`、`aaa`
- 布尔字面量：`true`、`false`

### -04. 数据类型转换

#### (1) 什么是数据类型转换

使用表单、`prompt`获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。 通俗来说，就是**把一种数据类型的变量转换成另外一种数据类型** 我们通常会实现3种方式的转换：

- 转换为字符串类型
- 转换为数字型
- 转换为布尔型

#### (2)转换成字符串

一般用第三种方式，隐式转换。

- `toString()` 方法
- `String()` 方法，强制转换
- 加号 `+` 拼接字符串

```js
var num = 12;
console.log(num.toString());
console.log(String(num)); // 强制转换
console.log(num + '');
```

引申：数字字符长转数字

```js
var str = '123'
console.log(str - '');
```

#### (3)转换为数字型

| 方式                    | 说明                       | 案例                                    |
| ----------------------- | -------------------------- | --------------------------------------- |
| `parseInt(str)` 函数    | string->整数型             | parseInt('10')                          |
| `parseFloat()` 函数     | string->浮点型             | parseFloat('3.14')                      |
| `Number()` 强制转换函数 | string->数字型             | Number('12')                            |
| JS 隐式转换             | 算术运算符隐式转换为数字型 | `'12'-  0` 或 `'12' - ''` 或 `'12' * 1` |

```js
console.log(parseInt('123')); // 123
console.log(parseFloat('3.14')); // 3.14
console.log('123' - 0); // 123
console.log('123' - ''); // 123
console.log(parseFloat('999')); // 999
console.log(parseInt('3.14159')); // 3
console.log(parseInt('120px')); // 120
console.log(Number('100')); // 100
console.log(Number('100.32')); // 100.32
console.log(Number('100px')); // NaN
console.log('100px' - ''); // NaN
```

注意：

1. 数字字符串（`'12.3'`，`12`）之间进行加法运算实际上是字符串的拼接，结果还是字符串；而数字字符串之间的减法运算是算术运算，结果是数字型。
2. 一个数字字符长和一个数字相乘，结果是算数运算结果，为数字型。

```js
console.log('10' + '2'); // 102
console.log('10' - '2'); // 8
console.log('10' + '3.2'); // 103.2
console.log('10' - '3.2'); // 6.8
console.log('12'*3); // 36
```

#### (4) 转换为布尔型

使用 `Boolean()` 函数转换。

- 转换值为 `false`：`''`, `0`, `NaN`, `null`, `undefined`（5个）
- 其他的转换值均为 `true`

```js
console.log(Boolean('')); // false
console.log(Boolean(0)); // false
console.log(Boolean(NaN)); // false
console.log(Boolean(null)); // false
console.log(Boolean(undefined)); // false
console.log(Boolean([])); // true
```

### -05. 标识符、关键字、保留字

#### (1) 标识符

标识（zhi）符：就是指开发人员为变量、属性、函数、参数取的名字。标识符不能是关键字或保留字。

#### (2) 关键字

关键字：是指JS本身已经使用了的字，不能再用它们充当变量名、方法名。

包括: `break`, `case`,` catch`, `continue`, `default`,` delete`, `do`,` else`, `finally`,` for`, `function`, `if`, `in`,` instanceof`, `new`,` return`, `switch`, `this`, `throw`, `try`, `typeof`, `var`, `void`, `while`, `with`等。

#### (3)保留字

保留字：实际上就是预留的“关键字” ，意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当变量名或方法名。

包括: `boolean`, `byte`,` char`,` class`,` const`,` debugger`,` double`,` enum`,` export`,` extends`,` fimal`, `float`,` goto`, `implements`, `import`, `int`, `interface`,` long`, `mative`, `package`,` private`, `protected`, `public`, `short`, `static`, `super`, `synchronized`, `throws`,` transient`,` volatile`等。

### -06. 拓展：8 种基本数据类型

8 种基本数据类型中，前 7 种为基本数据类型，最后 1 种为复杂数据类型（`object`）。

- `number`：用于任何类型的数字：整数或浮点数，在 \pm(2^{53}-1)±(253−1) 范围内的整数。
- `bigint`：用于任意长的整数。
- `string`：字符串，一个字符串可以包含 0 个或多个字符，没有单独的单字符类型。
- `boolean`：值为 `true` 或 `false`
- `null`：未知的值，只有一个 `null` 值的独立类型。
- `undefined`：未定义得值，只有一个 `undefined` 值的独立类型。
- `symbol`：用于唯一的标识符。
- `object`：用于更复杂的数据结构。

使用 `typeof` 运算符查看变量的数据类型：

- 两种形式：`typeof x` 或 `typeof(x)`
- 以字符串的形式返回类型名称：例如 `string`
- `typeof null` 会返回 `"object"` —— 这是 JavaScript 编程语言的一个错误，实际上它并不是一个 `object`。

## JS运算符

运算符（ operator ）也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号。 JavaScript常用的运算符有：

- 算术运算符
- 递增和递减运算符
- 比较运算符
- 逻辑运算符
- 赋值运算符

### -01. 算数运算符

加（`+`）、减（`-`）、乘（`*`）、除（`/`）、取余（`%`）

#### (1) 浮点数的精度问题

浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数。

```js
var result =0.1+0.2; // 结果不是0.3,而是: 0.30000000000000004 
console.log(0.07 * 100); // 结果不是7， 而是： 7.000000000000001
```

注意：

1. JS 中不要直接用浮点数之间进行运算，会产生精度误差。
2. 不要直接拿两个浮点数进行比较！

#### (2)表达式和返回值

表达式：是由数字、运算符、变量等以能求得数值的有意义排列方法所得的组合 。

> - **表达式是由数字、运算符、变量等组成的式子**
> - **表达式最终都会有一个结果，返回给我们，我们称为返回值**

### -02. 递增递减运算符

#### (1)递增和递减运算符概述

如果需要反复给数字变量添加或减去1，可以使用递增（`++`）和递减（`-- `）运算符来完成。 在JavaScript 中，递增（`++`）和递减（`-- `）既可以放在变量前面，也可以放在变量后面。

放在变量前面时，我们可以称为前置递增（递减）运算符，放在变量后面时，我们可以称为后置递增（递减）运算符。

注意：**递增和递减运算符必须和变量配合使用。**

- 后置递增运算符 `i++`
- 前置递增运算符 `++i`
- 后置递减运算符 `i--`
- 前置递减运算符 `--i`

#### (2)前置递增和后置递增小结

- 前置递增和后置递增运算符可以简化代码的编写，让变量的值+ 1 比以前写法更简单
- 单独使用时，运行结果相同
- 与其他代码联用时，执行结果会不同
- **后置：先原值运算，后自加（先人后己）**
- **前置：先自加，后运算（先已后人）**
- 开发时，大多使用后置递增/减，并且代码独占一行，例如：`num++ ;` 或者`num-- ;`

### -03. 比较运算符

#### (1) 概述

概念：**比较运算符（关系运算符）**是两个数据进行比较时所使用的运算符，比较运算后，会**返回一个布尔值** （true / false）作为比较运算的结果。

| 比较运算符 | 说明                                                    |
| ---------- | ------------------------------------------------------- |
| `<`        | 小于                                                    |
| `>`        | 大于                                                    |
| `<=`       | 大于或等于                                              |
| `>=`       | 小于或等于                                              |
| `==`       | 判等于                                                  |
| `!=`       | 判不等                                                  |
| `===`      | 全等于。要求值和数据类型均一致，则返回 `true`           |
| `!==`      | 全不等于。要求值和数据类型至少一个不一致，则返回 `true` |

#### (2) 关于 `==` 与 `===`

##### 1. 区别

需要注意的是 `==` 和 `===` 的区别。

- `==` 比较的时候只判断值，因为会进行隐式转换。值相等则返回 `true`
- `===` 比较判断的时同时需要值相等和类型相同，两者均满足则返回 `true`

##### 2. 规律

结合以下例子体会。

- `''`、`0`、`false` 之间（或 `'1'`、`1`、`true`之间）进行 `==` 比较的结果为 `true`
- `NaN` 与其他任何数据类型之间 `==` 比较结果为 `false`
- `null` 只有在和自身以及 `undefined` 之间 `==` 比较时结果为 `true`
- `undefined` 只有在和自身以及 `null` 之间 `==` 比较时结果为 `true`
- 数字和数字字符串的值相等，则 `==` 比较的结果为 `true`
- 以上这些例子在全等比较 `===` 下的结果均为 `false`

```js
console.log('18' == 18); // true
console.log('' == false); // truw
console.log('' == 0); // truw
console.log(0 == false); // true
console.log('1' == 1 == true); // true

/*--------- NaN与其他值比较: ---------*/
console.log(NaN == 0); // false
console.log(NaN == ''); // false
console.log(NaN == NaN); // false
console.log(NaN == null); // false
console.log(NaN == false); // false
console.log(NaN == undefined); // false

/*--------- null与其他值比较: ---------*/
console.log(null == null); // true
console.log(null == undefined); // true
console.log(null == 0); // false
console.log(null == ''); // false
console.log(null == NaN); // false
console.log(null == false); // false

/*--------- undefined与其他值比较: ---------*/
console.log(undefined == null);  // true
console.log(undefined == undefined);  // true
console.log(undefined == 0);  // false
console.log(undefined == '');  // false
console.log(undefined == NaN);  // false
console.log(undefined == false);  // false
```

### -04. 逻辑运算符

#### (1)概述

概念：**逻辑运算符是用来进行布尔值运算的运算符**，其**返回值也是布尔值**。后面开发中经常用于多个条件的判断

- 逻辑与 `&&` ，简称“与” and
- 逻辑或 `||` ，简称“或” or
- 逻辑非 `!` ，简称“非” not

#### (2) 逻辑中断（短路操作）

原理：多个表达式进行逻辑运算，当左边的表达式值可以确定最终结果时，不再继续运算右边其余的表达式。

##### 1. 逻辑与 &&

两边都是 `true`才返回` true`，否则返回 `false`

> 只要有一侧为 `false` ,结果就为 `false`

```js
console.log(123 && 456); // 456
console.log(false && 123); // false
console.log(1 && 2 && 3); // 3
console.log(1 && 1 && false && 2); // false
```

##### 2. 逻辑或 ||

两侧都为`false` 结果才是` false` 

> 只要有一侧为 `true`, 结果就是 `true`

```js
console.log(0 || 12); // 12
console.log(true ||  false || 2); // true
console.log(0 || false || true || -2); // true
```

### -05. 赋值运算符

概念：用来把数据赋值给变量的运算符

| 赋值运算符       | 说明                 | 举例                      |
| ---------------- | -------------------- | ------------------------- |
| `=`              | 直接赋值             | `var userName = '我是值'` |
| `+=`、`-=`       | 加、减一个数后再赋值 | `n += 5 `→ `n = n + 5`    |
| `*=`、`/=`、`%=` | 乘、除、取模后再赋值 | ` a *= 5 ` → `n = n * 5`  |

```js
var a = 10;
a -= 6; // 4 相当于 a = a - 6; 其余同理
```

### -06. 拓展：JS特殊运算符

#### (1) 数字转化：单目运算符 `+`

单目运算符 `+` 作用于数字无效，结果不变。但是可以用来转化非数字类型为数字，等效于 `Number()`。

```javascript
let x = false;
let y = "";
let z = "123.4";
console.log(+x); // 0
console.log(+y); // 0
console.log(+z); // 123.4
```

用于非数字型之间的数学运算，很简洁：

```javascript
let a = "12";
let b = "24";
console.log(+a + +b); // 36
```

#### (2) 逗号运算符 `,`

逗号运算符能让我们处理多个语句，使用 `,` 将它们分开。每个语句都运行了，**但是只有最后的语句的结果会被返回**。

```javascript
let a = (3 + 4, 5 + 6);
console.log(a); // 11
```

#### (3) 布尔值转换符 `!!`

两个相邻的逻辑非运算符组成的 `!!`，可以将一个值转换为对应的布尔值。等效于 `Boolean()`。

```javascript
console.log(!!"0"); // true
console.log(!!0); // false
console.log(!!undefined); //false
console.log(!!"aaa"); // true
```

#### (4)空值合并运算符 `??`

我们将值既不是 `null` 也不是 `undefined` 的表达式定义为已定义的值（defined）。即：`??`。

`a ?? b` 结果为：

- 若 `a` 已定义，则结果为 `a`
- 若 `a` 不是已定义的，则结果为 `b`

等价于：

```javascript
(a !== null && a !== undefined) ? a : b;
```

## 流程控制

简单理解： **流程控制就是来控制代码按照什么结构顺序来执行**

流程控制主要有三种结构：**顺序结构**、**分支结构**和**循环结构**，这三种结构代表三种代码执行的顺序。

### -01.顺序流程控制

顺序结构是程序中最简单、最基本的流程控制，它没有特定的语法结构，**程序会按照代码的先后顺序，依次执行**，程序中大多数的代码都是这样执行的。

### -02.分支流程控制

#### 分支结构

由上到下执行代码的过程中，根据不同的条件，执行不同的路径代码（**执行代码多选一的过程**），从而得到不同的结果。

JS 语言提供了两种分支结构语句：**if 语句** 、 **switch语句**。

#### (1)分支流程控制`if`语句

##### 1. `if `语句

```js
// 条件成立执行代码，否则跳过if语句直接执行其他语句
if (条件表达式) {
  ... // 条件成立执行的代码语句
}
... // 其他语句
```

##### 2. `if else` 语句（双分支语句）

```js
// 条件成立 执行 if 里面代码，否则执行else 里面的代码
if (条件表达式) {
 // [如果] 条件成立执行的代码
} else {
 // [否则] 执行的代码
}
```

##### 3. `if else if `语句（多分支语句）

```js
// 适合于检查多重条件。
if (条件表达式1) {
 ... // 语句1
} else if (条件表达式2) {
 ... // 语句2
} else if (条件表达式3) {
 ... // 语句3
 ....
} else {
 ... // 上述条件都不成立执行此处代码
}
```

##### 4.三元表达式

三元表达式也能做一些简单的条件选择。 有三元运算符组成的式子称为三元表达式。

```js
表达式1 ? 表达式2 : 表达式3;
```

执行思路：

- 如果表达式1为 true ，则返回表达式2的值
- 如果表达式1为 false，则返回表达式3的值 
- 简单理解： 就类似于 if else （双分支） 的简写

#### (2)分支流程控制`switch`语句

`switch` 语句也是多分支语句，它**用于基于不同的条件来执行不同的代码**。当要**针对变量设置一系列的特定值的选项时**，就可以使用 `switch`

```js
switch( 表达式 ){ 
 case value1:
   ... // 表达式 等于 value1 时要执行的代码
   break;
 case value2:
   ... // 表达式 等于 value2 时要执行的代码
   break;
 default:
   ... // 表达式 不等于任何一个 value 时要执行的代码
}
```

**语法结构**：

- `switch `：开关 转换 ， `case` ：小例子 选项
- 关键字 `switch` 后面括号内可以是表达式或值， 通常是一个变量
- 关键字` case `, 后跟一个选项的表达式或值，后面跟一个冒号
- `switch` 表达式的值会与结构中的` case` 的值做比较
- 如果存在匹配全等(`===`) ，则与该 `case` 关联的代码块会被执行，并在遇到 `break` 时停止，整个 `switch` 语句代码执行结束
- 如果所有的 `case` 的值都和表达式的值不匹配，则执行 `default` 里的代码

> **注意：** 执行`case` 里面的语句时，如果没有`break`，则继续执行下一个`case`里面的语句。

#### (3)`switch` 语句和 `if else if `语句的区别

- 一般情况下，它们两个语句可以相互替换
- `switch...case` 语句通常处理 `case`为比较确定值的情况， 而` if…else…`语句更加灵活，常用于范围判断(大于、等于某个范围) 
- **`switch` 语句进行条件判断后直接执行到程序的条件语句**，效率更高。而**`if…else` 语句有几种条件，就得判断多少次**。
- 当分支比较少时，`if… else`语句的执行效率比 `switch`语句高。 
- 当分支比较多时，`switch`语句的执行效率比较高，而且结构更清晰

### -03.循环流程控制

**循环目的**：在实际问题中，有许多**具有规律性的重复操作**，因此在程序中要完成这类操作就需要**重复执行某些语句**。

- **循环体**：在程序中，一组被重复执行的语句。
- **循环的终止条件**：决定循环体是否继续重复执行。
- **循环语句**：由循环体及循环的终止条件组成的语句。

JS中的循环：`for` 循环 、`while` 循环 、`do...while`循环

#### (1) `for` 循环

##### 1.语法结构

for 循环主要用于把某些代码循环若干次，**通常跟计数有关系**。

```js
for(初始化变量; 条件表达式; 操作表达式 ){
  ... // 循环体
}
```

- **初始化变量：**通常被用于初始化一个计数器，该表达式可以使用 `var` 关键字声明新的变量，用来记录次数。
-  **条件表达式：**用于确定每一次循环是否能被执行。如果结果是 `true` 就继续循环，否则退出循环。
- **操作表达式：**每次循环的最后都要执行的表达式。通常被用于更新或者递增计数器变量。当然，递减变量也是可以的。

##### 2.执行过程

1. 初始化变量，初始化操作在整个 `for `循环只会执行一次**。** 
2. 执行条件表达式，如果为`true`，则执行循环体语句，否则退出循环，循环结束。
3.  执行操作表达式，此时第一轮结束。
4. 第二轮开始，直接去执行条件表达式（不再初始化变量），如果为 `true` ，则去执行循环体语句，否则退出循环。
5.  继续执行操作表达式，第二轮结束。
6. 后续跟第二轮一致，直至条件表达式为假，结束整个 `for` 循环。

##### 3.`for`循环示例

for循环可以重复相同的代码 ，比如我们要输出10句“你吃了吗”

```js
for (var i = 1; i <= 10; i++) {
    console.log('你吃了吗')
}
```

##### 4.断点调试

断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。

**断点调试可以帮我们观察程序的运行过程**

浏览器中按 F12--> sources -->找到需要调试的文件-->在程序的某一行设置断点

Watch: 监视，通过watch可以监视变量的值的变化，非常的常用。

F11: 程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。

#### (2)双重`for`循环

很多情况下，单层`for `循环并不能满足我们的需求，此时就可以通过循环嵌套来实现。

**循环嵌套**是指在一个循环语句中再定义一个循环语句的语法结构，例如在`for`循环语句中，可以再嵌套一个`for `循环，这样的 `for `循环语句我们称之为双重`for`循环。

示例：打印五行五列星星

```js
 var star = '';
 for (var i = 1; i <= 5; i++) { // 外层循环
     for (var j = 1; j <= 5; j++) { // 内存循环
         star += '☆';
     }
     star += '\n' // 每次满 5个星星 就 加一次换行
 }
 console.log(star)
```

- 内层循环可以看做外层循环的语句
- 内层循环执行的顺序也要遵循 for 循环的执行顺序 
- **外层循环执行一次，内层循环要执行全部次数**

#### (3) `while` 循环

`while` 语句可以在条件表达式为真的前提下，循环执行指定的一段代码，直到表达式不为真时结束循环。

```js
while (条件表达式) {
 ... // 循环体代码
}
```

**执行思路：** 

1. 先执行条件表达式，如果结果为 `true`，则执行循环体代码；如果为 `false`，则退出循环，执行后面代码
2. 执行循环体代码
3.  循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为`true`，则会继续执行循环体，直到循环条件为 `false` 时，整个循环过程才会结束

> **注意：**
>
> - 使用 while 循环时一定要注意，它必须要有退出条件，否则会成为死循环
> - while 循环和 for 循环的不同之处在于 while 循环可以做较为复杂的条件判断，比如判断用户名和密码

示例： 

```js
var num = 1; // 计数器 初始化变量
while (num <= 100) {
    console.log('你好啊');
    num++; // 操作表达式 完成计数器的更新 防止死循环
}
```

```js
 var love = prompt('你爱我吗？'); // 初始化变量 
 while (love !== '我爱你') { // 条件表达式
     love = prompt('你到底爱不爱我!'); // 这个例子的循环体同时也是退出条件
 }
 alert('可是我不爱你啊');
```

#### (4) `do while` 循环

`do... while` 语句其实是 `while` 语句的一个变体。该循环会先执行一次代码块，然后对条件表达式进行判断，如果条件为真，就会重复执行循环体，否则退出循环。

```js
do {
// 循环体代码 - 条件表达式为 true 时重复执行循环体代码
} while(条件表达式);
```

**执行思路：**

1. 先执行一次循环体代码
2. 再执行条件表达式，如果结果为 `true`，则继续执行循环体代码，如果为 `false`，则退出循环，继续执行后面代码

> **注意：**先执行循环体，再判断，我们会发现 `do…while` 循环语句**至少会执行一次循环体代码**

#### (5) `continue` 和 `break`

##### 1. `continue` 关键字

**`continue` 关键字**用于立即**跳出本次循环**，**继续下一次循环**（本次循环体中 `continue` 之后的代码就会少执行一次）。

例如，吃5个包子，第3个有虫子，就扔掉第3个，继续吃第4个第5个包子，其代码实现如下：

```js
for (var i = 1; i <= 5; i++) {
   if (i == 3) {
       console.log('这个包子有虫子，扔掉');
       continue; // 跳出本次循环，跳出的是第3次循环
   }
   console.log('我正在吃第' + i + '个包子呢');
}
```

##### 2. `break` 关键字

**`break` 关键字用于**立即**跳出整个循环**（循环结束）。

例如，吃5个包子，吃到第3个发现里面有半个虫子，其余的不吃了，其代码实现如下：

```js
for (var i = 1; i <= 5; i++) {
   if (i == 3) {
      break; // 直接退出整个for 循环，跳到整个for下面的语句
   }
   console.log('我正在吃第' + i + '个包子呢');
}
```

## 数组

### -01. 基本概念

数组(Array) : 就是**一组数据的集合**，存储在单个变量下的优雅方式

### -02. 创建数组

#### (1)数组字面量创建数组

利用数组字面量`[]`创建数组， 数组里面可以存放任意类型的数据，例如字符串，数字，布尔值等。

1. 创建空数组

   ```js
   var arr = [];
   ```

2. 创建一般数组

   ```js
   var arr = [1, 2, 3];
   ```

- 数组里面的数据一定用逗号分隔
- 数组里面的数据 例如 1,2 我们称为**数组元素**

#### (2)new Array 创建数组对象

1. 创建空数组

   ```js
   var arr = new Array();
   ```

2. 创建指定长度的数组，有2个空数组元素

   ```js
   var arr1 = new Array(2);
   ```

3. 创建放有指定元素的数组（[2, 3]）

   ```js
   var arr2 = new Array(2, 3);
   ```

### -03. 基本操作

1. 数组元素访问

   ```js
   var e = arr[index];
   ```

2. 获取数组长度

   ```js
   var len = arr.length;
   ```

3. 数组遍历
   方式一：

   ```js
   for (var i = 0; i < arr.length; i++) {
       console.log(arr[i]);
   }
   ```

   方式二：

   ```js
   for (const i in arr) {
       console.log(arr[i]);
   }
   ```

4. 数组逆转

   ```js
   // 反转数组
   function reverse(arr) {
       var res = [];
       for (var i = arr.length - 1; i >= 0; i--) {
           res[res.length] = arr[i];
       }
       return res;
   }
   console.log(reverse([1, 2, 3, 4, 0])); // [0, 4, 3, 2, 1]
   ```

## 函数

### -01. 概述

**函数：就是封装了一段可被重复调用执行的代码块**。通过此代码块可以**实现大量代码的重复使用**。 

**封装**：把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口。

### -02. 函数的声明与调用

```js
// 1.声明函数
function 函数名() {
  //函数体代码
}
// 2.调用函数
函数名(); // 通过调用函数名来执行函数体代码
```

- `function`是声明函数的**关键字，必须小写**
- 由于函数一般是为了实现某个功能才定义的， 所以通常我们将**函数名**命名为**动词**，比如 getSum 。
- 调用函数的时候千万**不要忘记添加小括号**
- 口诀：函数不调用，自己不执行。

> **注意**：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码

### -03. 函数的参数

**形参**：**函数声明时**函数名括号里面的参数，默认值`undefined`（类似声明变量未赋值）

**实参**：**调用函数时**函数名括号里面的参数，实参是传递给形参的。（类似给形参赋值）

> 参数的作用：在**函数内部**某些值不能固定，我们可以通过参数在**调用函数时传递**不同的值进去。

```js
// 带参数的函数声明
function 函数名(形参1, 形参2 , 形参3...) { // 可以定义任意多的参数，用逗号分隔
 // 函数体
}
// 带参数的函数调用
函数名(实参1, 实参2, 实参3...);
```

#### (1) 实参个数与形参个数不匹配的情况

| 参数个数           | 说明                                   |
| ------------------ | -------------------------------------- |
| 形参和实参个数相等 | 输出正确结果                           |
| 实参个数多于形参   | 只取到形参的个数                       |
| 实参个数少于形参   | 多的形参定义为`undefined`，结果为`NaN` |

```js
function sum(num1, num2) {
    console.log(num1 + num2);
}
sum(100, 200); // 300, 形参和实参个数相等，输出正确结果
sum(100, 400, 500, 700); // 500, 实参个数多于形参，只取到形参的个数
sum(200); // NaN, 实参个数少于形参，多的形参定义为undefined，结果为NaN
```

> 在JavaScript中，形参的默认值是 `undefined`。

### -04.函数的返回值

#### (1) `return` 语句

使用 `return`语句可以将函数的值返回给调用者。

```js
// 声明函数
function 函数名（）{
 ...// 函数体
 return 需要返回的值；// 注意：return后的代码不执行
 alert('我不会被执行，因为前面有return')
}
// 调用函数
函数名(); // 此时调用函数就可以得到函数体内return 后面的值
```

> - 在使用 `return` 语句时，函数会停止执行，并返回指定的值 
> - `return`**只能返回一个值**，如果用逗号隔开多个值，以最后一个为准
> - 如果函数没有 `return`，返回的值是 `undefined`

```js
function add(num1，num2){
  //函数体
 return num1,num2;
}
var resNum = add(21,6); // 调用函数，传入两个实参，并通过 resNum 接收函数返回值
console.log(resNum); // 6  return只返回一个值
```

#### (2)`break`,`continue`,`return`的区别

- `break` ：结束当前的循环体（如 `for`、`while`） 
- `continue` ：跳出本次循环，继续执行下次循环（如` for`、`while`）
- `return` ：不仅可以退出循环，还能够返回 `return` 语句中的值，同时还可以结束当前的函数体内的代码。

### -05. arguments 的使用

当我们不确定有多少个参数传递的时候，可以用 `arguments` 来获取。在 JavaScript 中，`arguments` 实际上是当前函数的一个**内置对象**。所有函数都内置了一个 `arguments` 对象，`arguments` 对象中**存储了传递的所有实参。** 

**`arguments`展示形式是一个伪数组**，因此可以进行遍历。伪数组具有以下特点：

- 具有 `length` 属性
- 按索引方式储存数据
- 不具有数组的 `push` , `pop` 等方法

```js
function maxValue() {
  var max = arguments[0];
  for (var i = 1; i < arguments.length; i++) {
      if (max < arguments[i]) {
         max = arguments[i];
      }
  }
  return max;
}
 console.log(maxValue(2, 4, 5, 9));
```

### -06. 两种声明函数的方法

#### (1) 自定义函数方式(命名函数)

利用函数关键字 function 自定义函数方式。

```js
function fn() { // 声明函数
   // 函数体
}
fn() // 调用函数
```

> - 因为有名字，所以也被称为**命名函数**
> - 调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面

#### (2)函数表达式方式（匿名函数）

```js
// 这是函数表达式写法，匿名函数后面跟分号结束
var fn = function(){...}；
// 调用的方式，函数调用必须写到函数体下面
fn();
```

- 因为函数没有名字，所以也被称为**匿名函数**
- 这个fn 里面存储的是一个函数 
- 函数表达式方式原理跟声明变量方式是一致的 
- 函数调用的代码必须写到函数体后面

## 作用域

### -01. 作用域概述

javaScript作用域： 就是代码名字（变量）在某个范围内起作用和效果。 **目的：提高程序的可靠性、减少命名冲突**。

js的作用域（es6之前）： 

- 全局作用域 ：整个`script`标签 或者是一个单独的js文件
- 局部作用域(函数作用域) ：在函数内部就是局部作用域， 这个代码的名字只在函数内部起效果和作用

### -02. 变量的作用域

变量的作用域： 根据作用域的不同我们变量分为**全局变量**和**局部变量**。

#### (1)全局变量

- 在全局作用域下声明的变量叫做全局变量（在函数外部定义的变量）。
- 全局变量在代码的任何位置都可以使用
- 注意：如果在函数内未声明直接赋值的变量也属于全局变量（不建议使用）

#### (2)局部变量

在局部作用域下声明的变量叫做局部变量（在函数内部定义的变量）

- 局部变量只能在该函数内部使用
- 在函数内部声明的变量是局部变量
- 函数的形参实际上就是局部变量

#### (3) 全局变量与局部变量区别

- 全局变量：在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存
- 局部变量：只在函数内部使用，当其所在的代码块被执行时，会被初始化；当代码块运行结束后，就会被销毁，因此更节省内存空间

### -03. `var`、`let`、`const`

ES6 以前，JS 没有**块级作用域**。ES6 新增 `let` 和 `const` 之后才有了块级作用域。 块级作用域是指用 `{}` 包括起来的一段代码，例如` if `、`while` 等等。 函数作用域就是指变量只在函数内部起作用。

- `var` 声明的是函数作用域的变量
- `let` 声明的是块级作用域的变量
- `const` 声明的是块级作用域的变量

### -04. 作用域链

- 只要是代码，就至少有一个作用域
- 写在函数内部的局部作用域
- 如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域
- 作用域链： 内部函数访问外部函数的变量，采取的是链式查找的方式来决定取哪个值 ，这种结构我们称为作用域链 （就近原则）

```js
 var num = 10;

 function fn() {// 外部函数
    var num = 20;
     
    function fun() { // 内部函数
       console.log(num); // 站在目标出发，一层一层往外查找
    }
    fun();
 }
 fn();
```

## 预解析

js引擎运行 js 分为两步： 

1. **预解析**： js引擎会把js 里面所有的var 还有 function 提升到当前作用域的最前面。
2. **代码执行**： 按照代码书写的顺序从上往下执行。

 预解析： 变量预解析（变量提升） 、 函数预解析（函数提升）

- **变量提升**： 把所有的**变量声明**提升到当前作用域的最前面 ，不提升赋值操作
- **函数提升**： 把所有的**函数声明**提升到当前作用域的最前面， 不调用函数

示例：

```js
// 案例1
var num = 10;
fun();
function fun() {
    console.log(num);
    var num = 20;
} 
// 相当于执行以下操作
var num;
function fun() {
    var num;
    console.log(num);
    num = 20;
}
num = 10;
fun();// undefined
```

## 对象

### -01. 什么是对象？

在JavaScript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。

对象是由属性和方法组成的。

- 属性：事物的**特征**，在对象中用**属性**来表示（常用名词）
- 方法：事物的**行为**，在对象中用**方法**来表示（常用动词）

### -02. 创建对象

- 使用**字面量**`{}`创建对象
- 使用 `new Object` 创建对象
- 利用**构造函数**创建对象

#### (1)利用字面量创建

**对象字面量：**就是花括号 `{}` 里面包含了表达这个具体事物（对象）的属性和方法。`{}`里面采取**键值对**的形式表示

- 键：相当于属性名
- 值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）

```js
var star = {
  name : 'pink',
  age : 18,
  sex : '男',
  sayHi : function(){
     alert('大家好啊~');
  }
};
```

对象的调用

- 对象里面的属性调用 : **对象.属性名** ，这个小点 `.` 就理解为“ **的** ”
- 对象里面属性的另一种调用方式 : **对象['属性名']**，注意方括号里面的属性**必须加引号**，我们后面会用 
- 对象里面的方法调用：**对象.方法名()** ，注意这个方法名字后面一定加括号

```js
console.log(star.name) // 调用名字属性  方式1
console.log(star['name']) // 调用名字属性 方式2
star.sayHi(); // 调用 sayHi方法 注意：一定不要忘记带后面的括号
```

#### (2)使用 `new Object` 创建对象

```js
// 创建空对象
var andy = new Obect();
// 添加属性和方法
andy.name = 'pink';
andy.age = 18;
andy.sex = '男';
andy.sayHi = function(){
 alert('大家好啊~');
}
```

#### (3)利用构造函数创建对象

**构造函数 ：**是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面

构造函数语法：

```js
// 定义
function ConFuncName(params) {
    this.attr = value;
    this.methods = function() {};
}
// 调用
var obj = new ConFuncName(params);
```

- 构造函数用于创建某一类对象，其**首字母要大写**。
- 函数内的属性和方法前面需要添加 `this` ，表示当前对象的属性和方法。
- 构造函数中不需要 `return` 返回结果。
- 当我们创建对象的时候，必须用 `new` 来调用构造函数。

举例

```js
function Person(name, age, sex) {
 this.name = name;
 this.age = age;
 this.sex = sex;
 this.sayHi = function() {
 alert('我的名字叫：' + this.name + '，年龄：' + this.age + '，性别：' + this.sex);
 }
}
var bigbai = new Person('大白', 100, '男');
var smallbai = new Person('小白', 21, '男');
console.log(bigbai.name);
console.log(smallbai.name);
```

#### 构造函数和对象

- 构造函数，如 `Stars()`，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class） 
- 创建对象，如 `new Stars()`，特指某一个，**通过 new 关键字创建对象的过程我们也称为对象实例化**

### -03. `new`关键字的执行过程

1. 在内存中创建一个空的对象；
2. `this` 指向这个空对象；
3. 执行构造函数里面的代码，给空对象添加属性和方法；
4. 返回此对象象（所以构造函数里面不需要`return`）。

### -04. 遍历对象

`for...in` 可以对数组和对象进行遍历。

语法

```js
for (变量 in 对象名字) {
 // 在此执行代码
}
```

语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 `k` 或者`key`。

```js
for (const k in obj) {
    console.log(k);  // 这里的 k 是属性名
    console.log(obj[key]); // 这里的 obj[k] 是属性值
}
```

## 内置对象

-  JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象
- 前面两种对象是JS 基础 内容，属于 ECMAScript； 第三个浏览器对象属于我们JS 独有的， 我们 JS API 讲解
- **内置对象就是指 JS 语言自带的一些对象**，**提供了一些常用的或是最基本而必要的功能（属性和方法），来帮助我们快速开发**
- JavaScript 提供了多个内置对象：`Math`、 `Date` 、`Array`、`String`等

MDN: https://developer.mozilla.org/zh-CN/

### -01. `Math`对象

#### (1) `Math`概述

Math 对象不是构造函数，它**具有数学常数和函数的属性和方法**。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。

```js
Math.PI // 圆周率
Math.floor() // 向下取整
Math.ceil() // 向上取整
Math.round() // 四舍五入版 就近取整 注意 -3.5 结果是 -3 
Math.abs() // 绝对值
Math.max()/Math.min() // 求最大和最小值
```

> **注意：上面的方法必须带括号**

#### (2) 随机数方法 `random()`

random() 方法可以随机返回一个小数，其取值范围是 [0，1)，左闭右开 0 <= x < 1 

得到一个两数之间的随机整数，包括两个数在内

```js
function getRandom(min, max) {
 return Math.floor(Math.random() * (max - min + 1)) + min; 
}
```

### -02.日期对象

#### (1) `Date`概述

- `Date` 对象和` Math` 对象不一样，他是一个构造函数，所以我们需要实例化后才能使用
- `Date` 实例用来处理日期和时间

#### (2) `Date()`方法的使用

1. 获取当前时间必须实例化

   ```js
   var now = new Date();
   console.log(now)
   ```

2. `Date()` 构造函数的参数

   > - 如果`Date()`不写参数，就返回当前时间
   > - 如果`Date()`里面写参数，就返回括号里面输入的时间，格式：new Date('2019-5-1 8:00:00') 或者new Date('2019/5/1')

#### (3)日期格式化

获取日期指定的部分：`dObj.方法名()`

| 方法名          | 说明                       |
| --------------- | -------------------------- |
| `getFullYear()` | 获取当年                   |
| `getMonth()`    | 获取当月（0-11）           |
| `getDate()`     | 获取当天日期               |
| `getDay()`      | 获取星期几（周日0到周六6） |
| `getHours()`    | 获取当前小时               |
| `getMinutes()`  | 获取当前分钟               |
| `getSeconds()`  | 获取当前秒钟               |

```js
var now = new Date('2022-3-13')
var year = now.getFullYear();
var month = now.getMonth() + 1;
var date = now.getDate();
var day = now.getDay();
var days = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];

console.log(year + '年' + month + '月' + date + '日' + ' ' + days[day]) // 2022年3月13日 星期日
```

#### (4) 时间戳

`Date`对象是基于1970年1月1日（世界标准事件）起的毫秒数。

获取日期的总的毫秒形式：

```js
// 1. valueOf(), getTime()
var date = new Date();
console.log(date.valueOf());
console.log(date.getTime());

// 2. 推荐写法
var date = +new Date();

// 3. H5新增写法,有兼容性问题
var date = Date.now();
```

### -03.数组对象

#### (1)数组对象的创建

- 字面量方式`[]`
- `new Array()`

#### (2) 检测一个值是否为数组

1.  `instanceof`

   ```js
   function isArray(test) {
       if (test instanceof Array) return true;
       return false;
   }
   console.log(isArray([1, 2])); // true
   console.log(isArray(1)); // false
   ```

2. `Array.isArray()`

   `Array.isArray()` 方法用于检测一个值是否为数组。

   ```js
   var arr = [1,2];
   console.log(Array.isArray(arr)) // true
   ```

#### (3)添加删除数组元素的方法

| 方法名           | 说明                                                     | 返回值             |
| ---------------- | -------------------------------------------------------- | ------------------ |
| `push(arg1,...)` | **末尾添加**一个或多个元素                               | 返回新的长度       |
| `pop()`          | 删除数组最后一个元素，数组长度减 1，无参数，修改了原数组 | 返回所删除元素的值 |
| `unshift()`      | 向数组的**开头添加**一个或多个元素，修改了原数组         | 返回新的长度       |
| `shift()`        | 删除数组的第一个元素，数组长度减 1，无参数，修改了原数组 | 返回第一个元素的值 |

#### (4)数组排序

| 方法名      | 说明                       | 是否修改原数组           |
| ----------- | -------------------------- | ------------------------ |
| `reverse()` | 颠倒数组中元素顺序，无参数 | 会改变原数组，返回新数组 |
| `sort()`    | 对数组的元素进行排序       | 会改变原数组，返回新数组 |

```js
var arr = [1, 64, 9, 6];
arr.sort(function(a, b) {
 return b - a; // 降序
 // return a - b; // 升序
});
console.log(arr)
```

> ` a - b;` 为升序，`b - a` 为降序。

#### (5) 数组索引方法

| 方法名          | 说明                                      | 返回值                            |
| --------------- | ----------------------------------------- | --------------------------------- |
| `indexOf()`     | 数组中查找指定元素的 **第一个索引**       | 若存在则返回索引号，否则返回 `-1` |
| `latsIndexOf()` | 查找指定元素在数组中的 **最后一个的索引** | 若存在则返回索引号，否则返回 `-1` |

`indexOf` 前面开始查找，`lastIndexOf` 从后面开始查找，但索引都是从前往后由 `0` 算起。

```js
let arr = ['red', 'green', 'blue', 'pink', 'blue'];
console.log(arr.indexOf('blue')); // 2
console.log(arr.lastIndexOf('blue')); // 4
console.log(arr.indexOf('yellow')); // -1
```

#### (6)数组去重

```js
// 数组去重
function unique(arr) {
    var res = [];
    for (var i = 0; i < arr.length; i++) {
        if (res.indexOf(arr[i]) === -1) {
            res.push(arr[i]);
        }
    }
    return res;
}
console.log(unique([ 2, 3, 3, 4, 5, 5 ])); // [ 2, 3, 4, 5 ]
```

#### (7) 数组与字符串互转

##### 1,数组转换为字符串

以下两种方法都**不改变原数组**。

| 方法名           | 说明                                             | 返回值     |
| ---------------- | ------------------------------------------------ | ---------- |
| `toString()`     | 将数组转换成字符串，逗号分隔每一项               | 一个字符串 |
| `join('分隔符')` | 把数组中的所有元素转换为一个字符串，自定义分隔符 | 一个字符串 |

示例

```js
var a = ['a', 'b', 'c', 'd', 'e'];

console.log(a.toString());  // a,b,c,d,e
console.log(a.join('')); // abcde
console.log(a.join('-')); // a-b-c-d-e
console.log(a); // [ 'a', 'b', 'c', 'd', 'e' ]
```

##### 2.字符串转换为数组

使用 `split()` 方法。

```js
let str = 'blue-green-pink-red';
let res = str.split('-');
console.log(res); // [ 'blue', 'green', 'pink', 'red' ]
```

#### (8)数组方法 `splice`

`splice()` 方法对数组添加/删除项目，`splice()` 方法会改变原始数组。

返回值：

- 如果删除了项目，返回包含删除项目的数组。
- 如果未删除项目，返回空数组。

```js
array.splice(index, howmany, item1, ....., itemX)
```

| 参数                | 描述                                                         |
| :------------------ | :----------------------------------------------------------- |
| *index*             | 必需。整数，指定在什么位置添加/删除项目，使用负值指定从数组末尾开始的位置。 |
| *howmany*           | 可选。要删除的项目数。如果设置为 0，则不会删除任何项目。     |
| *item1, ..., itemX* | 可选。要添加到数组中的新项目。                               |

### -04.字符串对象

#### (1)基本包装类型

为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：`String`、`Number`和 `Boolean`。

**基本包装类型**：**把简单数据类型包装成为复杂数据类型**，这样基本数据类型就有了属性和方法

```js
var str = 'andy'; // 要处理的简单数据类型
console.log(str.length);
```

执行过程如下：

```js
// 1. 生成临时变量，把简单类型包装为复杂数据类型
var temp = new String('andy');
// 2. 赋值给我们声明的字符变量
str = temp;
// 3. 销毁临时变量
temp = null;
```

#### (2)字符串的不可变

**指的是里面的值不可变**，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。

```js
var str = 'abc';
str = 'hello';
// 当重新给 str 赋值的时候，常量'abc'不会被修改，依然在内存中
// 重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变
// 由于字符串的不可变，在大量拼接字符串的时候会有效率问题
var str = '';
for (var i = 0; i < 100000; i++) {
 str += i;
}
console.log(str); // 这个结果需要花费大量时间来显示，因为需要不断的开辟新的空间
```

#### (3)根据字符串返回位置

字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会**返回一个新的字符串**。

- `indexOf('要查找的字符',开始的位置)`：返回指定内容在元字符串中的位置，如果找不到就返回-1，开始的位置是`index`索引号
- `lastindexOf()`：从后往前找，只找第一个匹配。

#### (4)根据位置返回字符（重点）

> `index`：字符串的索引号

- `charAt(index)`：返回指定位置的字符

  ```js
  str.charAt(0)
  ```

- `charCodeAt(index)`  ：获取指定位置处字符的 ASCII 码

  ```js
  str.charCodeAt(0)
  ```

- `str[index]`  获取指定位置处字符（HTML5，IE8+支持。和`charAt()`等效）

#### (5)字符串操作方法（重点）

| 方法名                 | 说明                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `concat(str1,str2...)` | 拼接字符串，两个或多个，等效于`+`                            |
| `substr(start,length)` | 从`start`位置开始(索引号)，`length`截取的个数                |
| `slice(start,end)`     | 从`start`位置开始，截取到`end`位置(不包括`end`)，两个都是索引号 |
| `substring(start,end)` | 与`slice`基本相同，但是不接受负值                            |

#### (6) `replace()`方法

`replace()`方法用于在字符串中用一些字符**替换**另一些字符

```js
replace(被替换的字符串，要替换为的字符串)
```

#### (7) `split()`方法

`split()`方法用于将字符串切分为数组。返回值是一个新数组。

```js
var str = 'a,b,c,d';
console.log(str.split(',')); // 返回的是一个数组 ['a','b', 'c', 'd']
```

#### (8) 转换大小写

- 转换大写：`toUpperCase() `
- 转换小写：`toLowerCase() `

## 简单类型与复杂类型

### -01.简单与复杂类型

简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型。 

- **值类型**：简单数据类型/基本数据类型，在存储时**变量中存储的是值本身**，因此叫做值类型。

  > 例如：`string`，`number`，`boolean`，`undefined`，`null`；

- **引用类型**：复杂数据类型，在存储时**变量中存储的仅仅是地址（引用）**，因此叫做引用数据类型。

  > 例如：通过 `new `关键字创建的对象（系统对象、自定义对象），如 `Object`、`Array`、`Date`等

### -02.堆和栈

堆栈空间分配区别：

1. 栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；

   > **简单数据类型存放到栈里面**

2. 堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。

   > **复杂数据类型存放到堆里面**

> - 简单数据类型 `null` 返回的是一个空对象：`Object`。若有一个变量打算存储为对象但是没想好放什么，就可以给 `null` 值。
> - 简单数据类型是存放在栈里面，直接开辟空间存放值。
> - 复杂数据类型，首先在栈里面存放地址（十六进制），然后在堆里面存放值。

**注意：** **JavaScript中没有堆栈的概念**，通过堆栈的方式，可以让大家更容易理解代码的一些执行方式，便于将来学习其他语言

### -03.传参

#### (1)简单类型传参

函数的形参也可以看做是一个变量，当我们把一个**值类型变量作为参数**传给函数的形参时，其实是**把变量在栈空间里的值复制了一份给形参**，那么在方法内部对形参做任何修改，都**不会影响到外部的变量**。

```js
function fn(a) {
  a++;
  console.log(a); // 11
}
var x = 10;
fn(x);
console.log(x)；// 10
```

#### (2)复杂类型传参

函数的形参也可以看做是一个变量，当我们把**引用类型变量传给形参时**，其实是把变量在**栈空间里保存的堆地址复制给了形参**，形参和实参其实保存的是**同一个堆地址**，所以**操作的是同一个对象**。

```js
 function Person(name) {
     this.name = name;
 }
 function f1(x) {
     console.log(x.name); // 2. 刘德华
     x.name = '张学友';
     console.log(x.name); // 3. 张学友
 }
 var p = new Person('刘德华');
 console.log(p.name); // 1. 刘德华
 f1(p);
 console.log(p.name); // 4. 张学友
```

# Web API

## Web API简介

 JS 组成

- ECMAScript: JS 语法
- BOM: Web API
- DOM: Web API

API：Application Programming Interface，应用程序接口。

Web API 是浏览器提供得一套操作浏览器功能和页面元素的 API（BOM 和 DOM）。

## DOM基础

### -01. DOM简介

#### (1) 什么是 DOM

**文档对象模型**（Document Object Model，简称DOM )，是W3C组织推荐的处理可扩展标记语言（HTML或者XML)的标准编程接口。

W3C已经定义了一系列的DOM接口，通过这些DOM接口可以改变网页的内容、结构和样式。

#### (2) DOM 树

- **文档**：一个页面就是一个文档，DOM中使用document表示
- **元素**：页面中的所有标签都是元素，DOM中使用element表示
- **节点**：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM中使用`node`表示

> **以上内容都称之为对象**

### -02. 获取元素

#### 如何获取页面元素

**DOM 在我们实际开发中主要用来操作元素**。

获取页面中的元素可以使用以下几种方式:

- 根据ID获取
- 根据标签名获取
- 通过HTML5新增的方法获取
- 特殊元素获取

#### (1) 根据 ID 获取

使用 `getElementByld()` 方法可以获取带有 ID 的元素对象

```js
 document.getElementById('id');
```

> `console.dir()` 可打印获取的元素对象，查看对象里面的属性和方法。

#### (2)根据标签名获取

使用 `getElementsByTagName()` 方法可以返回带有指定标签名的**对象的集合**。

```js
 document.getElementsByTagName('标签名');
```

- 返回的是 **元素对象的集合，伪数组形式表示**。
- 想要操作里面的元素就需要遍历。。
- 得到的元素对象是动态的。
- 若没有元素，则返回空的伪数组 `[]`。

#### (3) 通过 HTML5 新增方法获取

1. 根据类名返回元素对象集合。

   ```js
    document.getElementsByClassName('类名')；
   ```

2. 根据指定选择器返回第一个元素对象。

   ```js
   document.querySelector('选择器'); 
   ```

3. 返回指定选择器的所有元素集合。

   ```js
   document.querySelectorAll('选择器')
   ```

> 注意：`querySelector` 和 `querySelectorAll`里面的选择器需要加符号,比如：`document.querySelector('#nav')`;

对于这些获取事件，会返回一个元素对象 或 一个对象集合。对于返回的对象集合，都可以是作为一种伪数组，可以通过 `elems.length` 来获取元素对象个数。

#### (4)获取特殊元素

1. 获取 `body` 元素

   ```js
   document.body // 返回body元素对象
   ```

2. 获取 `html` 元素

   ```js
    document.documentElement // 返回html元素对象
   ```

### -03.事件基础

#### (1)事件概述

JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。

简单理解： 触发--- 响应机制。

网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个事件，然后去执行某些操作。

#### (2)事件三要素

- 事件源：事件被触发的对象（例如按钮）。
- 事件类型：如何触发、什么事件（例如点击按钮）
- 事件处理程序：可通过一个函数赋值的方式实现。（做啥）

####  (3)执行事件的步骤

```html
<button class="btn">唐伯虎</button> //事件源
```

1. 获取事件源

   ```js
   var btn = document.querySelector('.btn')
   ```

2. 注册事件（绑定事件）

   ```js
   // btn.onclick
   ```

3. 添加事件处理程序（采取函数赋值形式）

   ```js
   btn.onclick = function() {
       alert('点秋香')
   }
   ```

#### (4)常见的鼠标事件

| 鼠标事件      | 触发条件         |
| ------------- | ---------------- |
| `onclick`     | 鼠标点击左键触发 |
| `onmouseover` | 鼠标经过触发     |
| `onmouseout`  | 鼠标离开触发     |
| `onfocus`     | 获得鼠标焦点触发 |
| `onblur`      | 失去鼠标焦点触发 |
| `onmousemove` | 鼠标移动触发     |
| `onmouseup`   | 鼠标弹起触发     |
| `onmousedown` | 鼠标按下触发     |

### -04.操作元素

JavaScript 的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容 、属性等。注意以下都是属性

#### (1)改变元素内容

1. 从起始位置到终止位置的内容, 但它**去除 html 标签**， 同时**去除空格和换行**

   ```js
   element.innerText
   ```

2. 起始位置到终止位置的全部内容，**包括 html 标签**，同时**保留空格和换行**

   ```js
   element.innerHTML
   ```

#### (2)常用元素的属性操作

1. `innerText`、`innerHTML` 改变元素内容
2. `src`、`href`
3. `id`、`alt`、`title`

示例

```html
 <button id="zxy">张学友</button>
 <img src="images/ldh.jpg" alt="" title='刘德华'>
```

```js
var zxy = document.getElementById('zxy');
var img = document.querySelector('img');
zxy.onclick = function () {
    img.src = 'images/zxy.jpg';
    img.title = '张学友';
}
```

#### (3)表单元素的属性操作

利用 DOM 可以操作如下表单元素的属性：

 `type`、`value`、`checked`、`selected`、`disabled`

#### (4)样式属性操作

我们可以通过 JS 修改元素的大小、颜色、位置等样式。

1. `element.style` 行内样式操作
2.  `element.className` 类名样式操作

> **注意**：
>
> - JS 里面的样式采取驼峰命名法 比如 `fontSize`、 `backgroundColor`
>
> - JS 修改 style 样式操作，产生的是行内样式，CSS 权重比较高
>
> -  如果样式修改较多，可以采取操作类名方式更改元素样式。
>
> - class 因为是个保留字，因此使用 `className` 来操作元素类名属性
>
> - `className` 会直接更改元素的类名，会覆盖原先的类名。如果想要保留原先的类名，可以使用多类名选择器
>
>   ​      `box.className = 'first change';`

#### (5)排他思想

如果有同一组元素，我们想要某一个元素实现某种样式， 需要用到循环的排他思想算法：

1.  所有元素全部清除样式（干掉其他人）
2. 给当前元素设置样式 （留下我自己）
3. 注意顺序不能颠倒，首先干掉其他人，再设置自己

```html
 <button>按钮1</button>
 <button>按钮2</button>
 <button>按钮3</button>
 <button>按钮4</button>
 <button>按钮5</button>
```

```js
var btns = document.querySelectorAll('button');
for (var i = 0; i < btns.length; i++) {
    // 1.干掉所有人
     btns[i].onclick = function () {
        for (var i = 0; i < btns.length; i++) {
            btns[i].style.backgroundColor = '';
        }
         // 2. 留下我自己
        this.style.backgroundColor = 'pink';
     }
}
```

> 排他思想：先排除其他人，然后才设置自己的样式

#### (6)元素属性操作

##### 1. 获取属性值

- ` element.属性` **获取内置属性值**（元素本身自带的属性）
- `element.getAttribute('属性')`;**主要获取自定义的属性** （标准） 我们程序员自定义的属性

##### 2.设置属性值

- `element.属性 = ‘值’` 设置内置属性值。
- `element.setAttribute('属性', '值')` 主要设置自定义的属性 （标准）；若属性已存在，则更新该属性值；否则，创建一个新属性。

> 使用 `element.属性` 获取或设置类名时，要用 `className`，而对于 `element.setAttribute()` 方法，直接使用 `class`，即：`div.setAttribute('class', 'footer')`。

##### 3. 移除属性

`element.removeAttribute('属性');`

#### (7)H5自定义属性

**自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。**

但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。H5给我们新增了自定义属性：

##### 1. 设置H5自定义属性

H5规定自定义属性`data-`开头做为属性名并且赋值。

```html
<div data-index="1"></div> <!--标签内直接设置 --> 
```

```js
// js中设置
element.setAttribute(‘data-index’, 2)
```

##### 2. 获取H5自定义属性

- 兼容性获取 element.getAttribute(‘data-index’);
-  H5新增 `element.dataset.index` 或者 `element.dataset[‘index’]` ie 11才开始支持

### -05.节点操作

#### (1)为什么学节点操作

获取元素通常使用两种方式:

1. 利用DOM提供的方法获取元素
   - `document.getElementByld()`
   - `document.getElementsByTagName()`
   - `document.querySelector()` 等
   - 缺点：逻辑性不强、繁琐
2. 利用 **节点层级关系** 获取元素
   - 利用父子兄节点关系获取元素
   - 优点：逻辑性强
   - 缺点：兼容性稍差

#### (2)节点概述

网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 `node` 来表示。

HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以创建或删除。

一般地，节点至少拥有`nodeType`（节点类型）、`nodeName`（节点名称）和 `nodeValue`（节点值）这三个基本属性

- 元素节点 `nodeType` 为 `1`
- 属性节点 `nodeType` 为 `2`
- 文本节点 `nodeType` 为 `3`（文字、空格、换行）

实际开发中，主要操作的还是元素节点。

#### (3)节点层级

利用 DOM 树可以把节点划分为不同的层级关系，常见的是**父子兄层级关系**。

##### 1.父级节点

获取离元素最近的父节点，若找不到则返回 `null`。

```js
 node.parentNode
```

##### 2.子节点

`parentNode.childNodes` 返回包含指定节点的子节点的集合，该集合为即时更新的集合。

```js
parentNode.childNodes
```

> **注意：返回值里面包含了所有的子节点，包括元素节点，文本节点等**。如果只想要获得里面的元素节点，则需要专门处理。 所以我们一般不提倡使用`childNodes`

```js
// 筛选元素节点
var ul = document. querySelector(‘ul’);
for (let i = 0; i < ul.childNodes.length; i++) {
     if (ul.childNodes[i].nodeType === 1) {
           console.log(ul.childNodes[i]);
     }
}
```

`parentNode.children` 是一个只读属性，**返回所有的子元素节点**。它只返回子元素节点，其余节点不返回 （**重点掌握**）。

```js
 parentNode.children[0] // 非标准，但更推荐
```

1. 获取第一个和最后一个**子节点**，找不到则返回`null`（包含所有的节点）
   - `parentNode.firstChild ` 获取第一个子节点
   - `parentNode.lastChild` 获取最后一个子节点
2. 获取第一个和最后一个**子元素节点**，找不到则返回`null`（不包含其他节点）
   - `parentNode.firstElementChild` 第一个
   - `parentNode.lastElementChild ` 最后一个

> **实际开发：**
>
> -  获取第一个子元素节点，使用 `parentNode.chilren[0] `
> - 获取最后一个子元素节点，使用 `parentNode.children[parentNode.children.length - 1]`

##### 3.兄弟节点

- 返回下一个兄弟节点：

  ```js
  node.nextSibling
  ```

- 返回上一个兄弟节点：

  ```js
  node.previousSibling
  ```

> `nextsibling` / `previousSibling` 返回当前元素的下 /上一个兄弟节点，找不到则返回 `null`。这个兄弟节点可能是所有的节点之一（即包括元素节点、文本节点等）。

- 返回下一个 **兄弟元素节点**（≥IE9）

  ```js
  node.nextElementSibling
  ```

- 返回上一个 **兄弟元素节点**（≥IE9）

  ```js
  node.previousElementSibling
  ```

> `nextElementSibling` / `previousElementSibling` 返回当前元素下/上一个兄弟元素节点，找不到则返回 `null`。这两个方法有兼容性问题，IE9 以上才支持。

解决方法：封装一个函数。

```js
// 处理 <IE9 兼容性问题
function getNextElementSibling(element) {
    var el = element;
    while (el = el.nextSibling) {
         if (el.nodeType === 1) {
             return el;
         }
    }
    return null;
 }
```

#### (4)操作节点

##### 1.创建节点

```js
document.createElement("tagName");
```

`document.createElement()` 方法创建由 `tagName` 指定的 HTML 元素。因为这些元素原先不存在，是根据我们的需求动态生成的，所以我们也称为 **动态创建元素节点**。

##### 2.添加节点

在创建了元素节点后，还需要将节点添加到页面中。

`node.appendChild()` 方法将一个节点添加到指定父节点的子节点列表末尾。类似于 CSS 里面的 `:after`伪元素。

```js
 Node.appendChild(child)
```

`node.insertBefore()` 方法将一个节点添加到父节点的指定子节点前面。类似于 CSS 里面的 `:before `伪元素

```js
 node.insertBefore(child, 指定元素)
```

##### 3.删除节点

`node.removeChild()` 方法从 DOM 中删除一个子节点，返回删除的节点

```js
node.removeChild(child) 
```

##### 4.复制节点（克隆节点）

`node.cloneNode()` 方法返回调用该方法的节点的一个副本。 也称为克隆节点/拷贝节点

```js
 node.cloneNode()
```

> **注意：**
>
> -  如果括号**参数为空或者为 `false`** ，则是**浅拷贝**，即只克隆复制节点本身，不克隆里面的子节点。
> - 如果括号**参数为 `true`** ，则是**深度拷贝**，会复制节点本身以及里面所有的子节点。

##### 5.三种动态创建元素区别

- `document.write()`
- `element.innerHTML`
- `document.createElement()`

**区别**

- `document.write` 是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致**页面全部重绘**
-  `innerHTML` 是将内容写入某个 DOM 节点，不会导致页面全部重绘\
- `innerHTML` 创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂
- `createElement()` 创建多个元素效率稍低一点点，但是结构更清晰

**总结**：不同浏览器下，`innerHTML` 效率要比 `creatElement` 高

### -06. DOM 重点核心总结

关于 dom 操作，我们主要针对于元素的操作。主要有创（建）、增、删、改、查、属性操作、事件操作。

#### (1) 创建

- `document.write`
- `innerHTML`
- `createElement`

#### (2) 增

- `appendChild`
- `insertBefore`

#### (3) 删

- `removeChild`

#### (4) 改

主要修改 dom 的元素属性，dom 元素的内容、属性，表单的值等。

- 修改元素属性：`src`、`href`、`title` 等
- 修改普通元素内容：`innerHTML`、`innerText`
- 修改表单元素：`value`、`type`、`disabled` 等
- 修改元素样式：`style`、`className`

#### (5) 查

主要获取查询dom的元素

- DOM提供的API 方法：`getElementById`、`getElementsByTagName`（**古老用法不太推荐**）
- H5提供的新方法：`querySelector`、`querySelectorAll` 提倡
- 利用节点操作获取元素：父（`parentNode`)、子（`children`）、兄（`previousElementSibling`、 `nextElementSibling`）提倡

#### (6)属性操作

主要针对于自定义属性

- `setAttribute`：设置dom的属性值
- `getAttribute`：得到dom的属性值
- `removeAttribute`：移除属性

#### (7) 事件操作

给元素注册事件，格式：`事件源.事件类型 = 事件处理程序`

| 鼠标事件      | 触发条件         |
| ------------- | ---------------- |
| `onclick`     | 鼠标点击左键触发 |
| `onmouseover` | 鼠标经过触发     |
| `onmouseout`  | 鼠标离开触发     |
| `onfocus`     | 获得鼠标焦点触发 |
| `onblur`      | 失去鼠标焦点触发 |
| `onmousemove` | 鼠标移动触发     |
| `onmouseup`   | 鼠标弹起触发     |
| `onmousedown` | 鼠标按下触发     |

## 事件高级

### -01.注册事件（绑定事件）

给元素添加事件，称为注册事件或者绑定事件。 注册事件有两种方式：**传统方式** 和 **事件监听注册方式**。

#### (1)注册事件概述

##### 1.传统注册方式

- 利用 `on` 开头的事件 例如：`onclick`
- `<button onclick="alert('hi~')"></button>`
- `btn.onclick = function() {};`
- 特点：注册事件的 **唯一性**
- 同一个元素同一个事件只能设置一个处理函数，最 后注册的处理函数将会 **覆盖** 前面注册的处理函数。

##### 2.事件监听注册方式

- w3c 标准推荐方式
- `addEventListener()` 它是一个方法
- IE9 之前的 IE 不支持此方法，可使用 `attachEvent()` 代替
- 特点：**同一个元素同一个事件可以注册多个监听器**
- 按注册顺序依次执行

#### (2) `addEventListener` 事件监听方式

```js
 eventTarget.addEventListener(type, listener[, useCapture])
```

`eventTarget.addEventListener()` 方法将指定的监听器注册到 `eventTarget`（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。

该方法接收三个参数：

- `type`：事件类型字符串，比如 `click` 、`mouseover`，注意这里不要带 `on`。
- `listener`：事件处理函数，事件发生时，会调用该监听函数
- `useCapture`：可选参数，是一个布尔值，默认是 `false`。学完 DOM 事件流后，我们再进一步学习。

#### (3) attachEvent 事件监听方式

```js
eventTarget.attachEvent(eventNameWithOn, callback)
```

`eventTarget.attachEvent()` 方法将指定的监听器注册到 `eventTarget`（目标对象）上，当该对象触 发指定的事件时，指定的回调函数就会被执行。 该方法接收两个参数：

- `eventNameWithOn`：事件类型字符串，比如 `onclick`、`onmouseover`，这里要带 `on`
- `callback`：事件处理函数，当目标触发事件时回调函数被调用

> IE8 及早期版本支持（**了解即可，非常不推荐**）

#### (4)注册事件兼容性解决方案

```js
function addEventListener(element, eventName, fn) {
 // 判断当前浏览器是否支持 addEventListener 方法
   if (element.addEventListener) {
      element.addEventListener(eventName, fn); // 第三个参数 默认是false
   } else if (element.attachEvent) {
      element.attachEvent('on' + eventName, fn);
   } else {
    // 相当于 element.onclick = fn;
      element['on' + eventName] = fn;
   }
}
```

> **兼容性处理的原则： 首先照顾大多数浏览器，再处理特殊浏览器**

### -02 删除事件（解绑事件）

#### (1) 传统注册方式

```js
eventTarget.onclick = null;
```

#### (2)方法监听注册方式

##### 1.` removeEventListener`（≥IE9）

```js
eventTarget.removeEventListener(type, listener[, useCapture]);
```

一个对象可能绑定了很多事件，对于 `removeEventListener` 方法，需要指定要删除的事件 `listener`。所以在注册事件的时候需要提前将事件函数封装在一个变量里。然后把变量传给`removeEventListener` 方法。

例如：

```js
var divs = document.querySelectorAll("div");
var func1 = function () {
    console.log("我是点击事件监听函数");
    divs[0].removeEventListener("click", func1);
};
btns[0].addEventListener('click', func1);
```

##### 2. `detachEvent`（<IE9支持，基本不用）

```js
divs[2].attachEvent('onclick',fn1);
function fn1() {
    divs[2].detachEvent('onclick',fn1);
} 
```

#### (3)删除事件兼容性解决方案

```js
function removeEventListener(element, eventName, fn) {
 // 判断当前浏览器是否支持 removeEventListener 方法
   if (element.removeEventListener) {
      element.removeEventListener(eventName, fn); // 第三个参数 默认是false
   } else if (element.detachEvent) {
      element.detachEvent('on' + eventName, fn);
   } else {
      element['on' + eventName] = null;
   }
}
```

### -03. DOM 事件流

#### (1) 定义

**事件流** 描述的是从页面中接收事件的顺序。

**事件** 发生时会在元素节点之间 **按照特定的顺序** 传播，这个传播过程即 **DOM 事件流**。

比如我们给一个 `div` 注册了点击事件。
DOM 事件流分为3个阶段：

```
捕获阶段 => 当前目标阶段 => 冒泡阶段
```

- **事件冒泡**：IE 最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点的过程。

- **事件捕获**：网景最早提出，由DOM 最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程。

  我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（最具体元素）之后漂浮到水面上，这个过程相当于事件冒泡。

![js1](https://cdn.jsdelivr.net/gh/Hacker-C/Picture-Bed@main/FrontEnd/js1.3f1t9u88n880.png)

注意：

1. JS 代码中只能执行捕获或者冒泡其中的一个阶段。
2. `onclick` 和 `attachEvent` 只能得到冒泡阶段。
3. `addEventListener(type, listener[, useCapture])` 第三个参数如果是 `true`，表示在事件捕获阶段调用事件处理程序；如果是 `false`（不写默认就是 `false`），表示在事件冒泡阶段调用事件处理 程序。
4. 实际开发中我们很少使用事件捕获，我们 **更关注事件冒泡**。
5. **有些事件是没有冒泡的**，比如 `onblur`、`onfocus`、`onmouseenter`、`onmouseleave`
6. **事件冒泡有时候会带来麻烦，有时候又会帮助很巧妙的做某些事件，我们后面讲解**。

### -04. 事件对象

#### (1) 什么是事件对象

```js
eventTarget.onclick = function(event) {}
eventTarget.addEventListener('click', function(event) {}）
// 这个event 就是事件对象，我们还喜欢的写成 e 或者evt
```

- 官方解释：`event` 对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态。
- 简单理解：事件发生后，跟 **事件相关的一系列信息数据的集合** 都放到这个对象里面，这个对象就是事件对象 `event`，它有很多属性和方法。

比如：

1. 谁绑定了这个事件。
2. 鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。
3. 键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。

#### (2)事件对象的使用语法

```js
eventTarget.onclick = function(event) {
// 这个event 就是事件对象，我们还喜欢的写成e 或者evt
}
eventTarget.addEventListener('click', function(event) {
// 这个event 就是事件对象，我们还喜欢的写成e 或者evt
}）
```

这个 `event` 是个形参，系统帮我们设定为事件对象，不需要传递实参过去。
当我们注册事件时，`event` 对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数）。

#### (3)对象的兼容性方案

事件对象本身的获取存在兼容问题：

1. 标准浏览器中是浏览器给方法传递的参数，只需要定义形参 `e` 就可以获取到。
2. 在IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 `window.event` 中获取查找。

解决方法：

```js
e = e || window.event;
```

#### (4) 事件对象的常见属性和方法

| 事件对象属性方法       | 说明                          |
| ---------------------- | ----------------------------- |
| `e.target`             | 返回触发事件的对象（标准）    |
| `e.srcElement`         | 返回触发事件的对象（非标准）  |
| `e.type`               | 返回事件类型                  |
| `e.preventDefault()`   | 阻止默认事件（标准）          |
| `e.returnValue = true` | 阻止默认事件（非标准，IE678） |
| `e.stopPropagation()`  | 阻止冒泡（标准）              |
| `e.cancelBubble`       | 阻止冒泡（非标准，IE678）     |

> 非标准（IE678）方案只需要了解。

#### (5) `e.target` 和 `this` 的区别

- `e.target`：`e.target` 返回的是触发事件的对象（元素），哪个元素触发了事件，就返回那个元素。
- `this`：事件绑定的元素，这个事件函数的调用者（绑定这个事件的元素）

> 点击了某一个元素节点，这个节点不一定绑定了事件。但是由于 DOM 事件流的冒泡现象，会触发其父节点所绑定的事件。

一个简单的例子：

```html
<body>
    <ul>
        <li>123</li>
        <li>456</li>
        <li>789</li>
    </ul>
 <script>
    var ul = document.querySelector("ul");
    ul.addEventListener('click', function (e) {
       // 点击 li 中的 123
       console.log(e.target); // <li>...</li>
       console.log(this); // <ul>...</ul>
    })
 </script>
</body>
```

#### (6)阻止事件默认行为

阻止 a 链接跳转:

- 标准

  ```js
  a.addEventListener ('click', function (e) {
      e.preventDefault();
  });
  ```

- 兼容IE678

  ```js
  a.onclick = function (e) {
      console.log(e);
      e.returnValue;
      // 或者
      return false;
  }
  ```

### -05. 阻止事件冒泡

#### (1)阻止事件冒泡的两种方式

事件冒泡：开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点。 

事件冒泡本身的特性，会带来的坏处，也会带来的好处，需要我们灵活掌握。

阻止事件冒泡：

- 标准写法：利用事件对象里面的`stopPropagation()`方法。

  ```js
  e.stopPropagation();
  ```

- 非标准写法：IE 6-8 利用事件对象`cancelBubble`属性

  ```js
  e.cancelBubble = true;
  ```

> 给相应的子元素节点设置事件的 `stopPropagation()` 方法，相当于在这个节点阻断了事件冒泡。事件无法继续传递至父节点。

一个例子：点击 son 子盒子，在设置阻断事件冒泡前，点击子盒子也触发了父盒子 fahter 的事件。设置了之后，打印台不再输出 father。

```html
<div class="father">
    <div class="son"></div>
</div>
<script>
var father = document.querySelector(".father");
var son = father.firstElementChild;
father.addEventListener('click', function () {
     console.log("fahter");
});
son.addEventListener('click', function (e) {
     e.stopPropagation();
});
</script>
```

#### (2) 阻止事件冒泡的兼容性解决方案

```js
if(e && e.stopPropagation) {
    e.stopPropagation();
} else {
    window.event.cancelBubble = true;
}
```

### -06事件委托（代理、委派）

生活中有如下场景：

- 咱们班有100个学生，快递员有100个快递，如果一个个的送花费时间较长。同时每个学生领取的时候，也需 要排队领取，也花费时间较长，何如？
- **解决方案**：快递员把100个快递，委托给班主任，班主任把这些快递放到办公室，同学们下课自行领取即可。
- **优势**：快递员省事，委托给班主任就可以走了。同学们领取也方便，因为相信班主任。

事件冒泡本身的特性，**会带来的坏处，也会带来的好处**，需要我们灵活掌握。程序中也有如此场景：

```html
<ul>
    <li>知否知否，应该有弹框在手</li>
    <li>知否知否，应该有弹框在手</li>
    <li>知否知否，应该有弹框在手</li>
    <li>知否知否，应该有弹框在手</li>
    <li>知否知否，应该有弹框在手</li>
</ul>
```

点击每个 `li` 都会弹出对话框，以前需要给每个 `li` 注册事件，是非常辛苦的，而且访问 DOM 的次数越多，这就会延长整个页面的交互就绪时间。

#### (1)事件委托的原理

- 事件委托：也称为事件代理，在jQuery 里面称为事件委派。
- 原理：**不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点**。
  以上案例：给 `ul` 注册点击事件，然后利用事件对象的 `target` 来找到当前点击的 `li`，因为点击 `li`，事件会冒泡到ul 上，`ul` 有注册事件，就会触发事件监听器。
- 作用：我们 **只操作了一次 DOM ，提高了程序的性能。**

### -07 常用的鼠标事件

#### (1) 鼠标事件默认行为

1. 禁止鼠标右键菜单
   `contextmenu` 主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单。

   ```js
   document.addEventListener('contextmenu', function(e) {
       e.preventDefault();
   })
   ```

2. 禁止鼠标选中（`selectstart` 开始选中）

   ```js
   document.addEventListener('selectstart', function(e) {
       e.preventDefault();
   })
   ```

#### (2)鼠标事件对象

`event` 对象代表事件的状态，跟事件相关的一系列信息的集合。现阶段我们主要是用鼠标事件对象 `MouseEvent` 和键盘事件对象 `KeyboardEvent`。

| 鼠标事件对象 | 说明                                      |
| ------------ | ----------------------------------------- |
| `e.clientX`  | 返回鼠标相对于浏览器窗口可视区的 `X` 坐标 |
| `e.clientY`  | 返回鼠标相对于浏览器窗口可视区的 `Y` 坐标 |
| `e.pageX`    | 返回鼠标相对于文档页面的 `X` 坐标IE9+支持 |
| `e.pageY`    | 返回鼠标相对于文档页面的 `Y` 坐标IE9+支持 |
| `e.screenX`  | 返回鼠标相对于电脑屏幕的 `X` 坐标         |
| `e.screenY`  | 返回鼠标相对于电脑屏幕的 `Y` 坐标         |

### -08. 常用的键盘事件

#### (1)常用的键盘事件

事件除了使用鼠标触发，还可以使用键盘触发。

| 键盘事件     | 触发事件                                                     |
| ------------ | ------------------------------------------------------------ |
| `onkeyup`    | 某个键盘按键被松开时触发                                     |
| `onkeydown`  | 某个键盘按键被按下时触发                                     |
| `onkeypress` | 某个键盘按键被按下时触发，但是不识别功能键（ctrl、shif、箭头等） |

**注意：**

1. 如果使用`addEventListener` 不需要加` on`
2. `onkeypress` 和前面2个的区别是，它不识别功能键，比如左右箭头，shift 等。
3. 三个事件的执行顺序是：` keydown` -- `keypress` --- `keyup`

#### (2) 键盘事件对象

| 键盘事件对象属性 | 说明                             |
| ---------------- | -------------------------------- |
| `key`            | 返回物理按键的名称值（推荐使用） |
| `keyCode`        | 返回该键的ASCII值                |

`keyCode` 已废弃：该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。一定要用，请使用 `key` 代替。——MDN

## BOM基础

### -01.BOM 概述

#### (1) 什么是DOM

BOM（Browser Object Model）即**浏览器对象模型**，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 `window`。

BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。

BOM 缺乏标准，JavaScript 语法的标准化组织是ECMA，DOM 的标准化组织是 W3C，BOM 最初是Netscape 浏览器标准的一部分

#### (2) DOM、BOM区别

| DOM                                      | BOM                                              |
| ---------------------------------------- | ------------------------------------------------ |
| 文档对象模型                             | 浏览器对象模型                                   |
| DOM 就是把「文档」当做一个「对象」来看待 | 把「浏览器」当做一个「对象」来看待               |
| DOM 的顶级对象是 `document`              | BOM 的顶级对象是 `window`                        |
| DOM 主要学习的是操作页面元素             | BOM 学习的是浏览器窗口交互的一些对象             |
| DOM 是W3C 标准规范                       | BOM 是浏览器厂商在各自浏览器上定义的，兼容性较差 |

#### (3) BOM 的构成

BOM 比 DOM 更加强大，包含了 DOM。

![bom1](https://cdn.jsdelivr.net/gh/Hacker-C/Picture-Bed@main/JavaScript/bom1.3ss67gfjn6c.png)

**`window` 对象是浏览器的顶级对象**，它具有双重角色。

1. 它是JS 访问浏览器窗口的一个接口。
2. 它是一个全局对象。定义在全局作用域中的变量、函数都会变成 `window` 对象的属性和方法。 在调用的时候可以省略 `window`，前面学习的对话框都属于 `window` 对象方法，如 `alert()`、`prompt()` 等。

> `window` 下的一个特殊属性 `window.name`。

### -02. window 对象的常见事件

#### (1) 窗口加载事件

##### 1.`onload`

```js
window.onload = function() {};
// 或者
window.addEventListener("load", function(){});
```

`window.onload` 是窗口（页面）加载事件,当文档内容完全加载完成会触发该事件（**包括图像、脚本文件、CSS文件等**）, 就调用的处理函数。

注意：

1. 有了 `window.onload` 就可以把 JS 代码写到页面元素的上方，因为onload 是等页面内容全部加载完毕， 再去执行处理函数。
2. `window.onload` 传统注册事件方式只能写一次，如果有多个，会以最后一个 `window.onload` 为准。
3. 如果使用 `addEventListener` 则没有限制。

##### 2. `DOMContentLoaded`

```js
document.addEventListener('DOMContentLoaded', function() {});
```

`DOMContentLoaded` 事件触发时，仅当DOM加载完成，**不包括样式表，图片，flash等等**。（Ie9以上才支持。）

> 如果页面的图片很多的话, 从用户访问到 `onload` 触发可能需要较长的时间, 交互效果就不能实现，必然影响用户的体验，此时用 `DOMContentLoaded` 事件比较合适。

#### (2)调整窗口大小事件

```js
window.onresize = function(){}
window.addEventListener("resize",function(){});
```

`window.onresize` 是调整窗口大小加载事件, 当触发时就调用的处理函数。 注意：

1. 只要窗口大小发生像素变化，就会触发这个事件。
2. 我们经常 **利用这个事件完成响应式布局**。
3. `window.innerWidth` 是当前屏幕的宽度

### -03.定时器

#### (1)两种定时器

`window` 对象给我们提供了2 个非常好用的方法——定时器。

- `setTimeout()`
- `setInterval()`

#### (2) `setTimeout()` 定时器

```js
window.setTimeout(调用函数 [, 延迟的毫秒数]);
```

`setTimeout()` 方法用于设置一个定时器，该定时器在定时器到期后执行调用函数。

注意：

1. `window` 可以省略。
2. 这个调用函数可以 **直接写函数，或者写函数名或者采取字符串'函数名()'** 三种形式。第三种不推荐。
3. 延迟的毫秒数省略默认是 `0`，如果写，**必须是毫秒**。
4. 因为定时器可能有很多，所以我们 **经常给定时器赋值一个标识符**。

`setTimeout()` 这个调用函数我们也称为 **回调函数callback**。 普通函数是按照代码顺序直接调用。而这个函数，需要等待时间，时间到了才去调用这个函数，因此称为回调函数。

> 简单理解：回调，就是回头调用的意思。上一件事干完，再回头再调用这个函数。

以前我们讲的 `element.onclick = function(){}` 或者 `element.addEventListener(“click”, fn);` 里面的函数也是回调函数。

#### (3)停止 `setTimeout()` 定时器

```js
window.clearTimeout(timeoutID)
```

`clearTimeout()` 方法用于取消先前通过调用 `setTimeout()` 建立的定时器。

> 1. `window` 可以省略。
> 2. 里面的 **参数就是定时器的标识符**。



#### (4) `setInterval()` 定时器

```js
window.setInterval(回调函数 [, 间隔的毫秒数]);
```

`setInterval()` 方法重复调用一个函数，每隔这个时间，就去调用一次回调函数。

**注意**：

1. `window` 可以省略。
2. 这个调用函数可以 **直接写函数，或者写函数名或者采取字符串'函数名()'** 三种形式。
3. 间隔的毫秒数省略默认是 `0`，如果写，必须是毫秒，表示每隔多少毫秒就自动调用这个函数。
4. 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。
5. **第一次执行也是间隔毫秒数之后执行，之后每隔毫秒数就执行一次**。

#### (5) 停止 `setInterval()` 定时器

```js
window.clearInterval(intervalID);
```

`clearInterval()` 方法取消了先前通过调用 `setInterval()` 建立的定时器。

注意：

1. `window` 可以省略。
2. 里面的参数就是定时器的标识符。

#### (6)this 指向问题

`this` 的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定 `this` 到底指向谁，一般情况下的最终指向的是那个调用它的对象 现阶段，我们先了解一下几个 `this` 指向：

1. 全局作用域或者普通函数中 `this` 指向全局对象 `window`（注意定时器里面的 `this` 指向 `window`）
2. 方法调用中谁调用 `this` 指向谁
3. 构造函数中 `this` 指向构造函数的实例

### -04.JS 执行机制

#### (1) JS 是单线程

JavaScript 语言的一大特点就是 **单线程**，也就是说，**同一个时间只能做一件事**。这是因为 Javascript 这门脚 本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作DOM 而诞生的。比如我们对 某个DOM 元素进行添加和删除操作，不能同时进行。应该先进行添加，之后再删除。

单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是：如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

#### (2) 同步和异步概述

先来看一个问题：以下代码执行的结果是什么？

```js
console.log(1);
setTimeout(function () {
    console.log(3);
}, 1000);
console.log(2);
// 1  2  3
```

那么以下代码执行的结果又是什么？

```js
console.log(1);
setTimeout(function () {
    console.log(3);
}, 0);
console.log(2);
// 1  2  3
```

为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创 建多个线程。于是，JS 中出现了 **同步和异步**。

##### 1. 同步

前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做 法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。

##### 2.异步

你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做 饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。

**他们的本质区别：这条流水线上各个流程的执行顺序不同**。

#### (3) 同步和异步任务

##### 1. 同步任务

同步任务都在主线程上执行，形成一个 **执行栈**。

##### 2. 异步任务

JS 的异步是通过回调函数实现的。 一般而言，异步任务有以下三种类型：

1. 普通事件，如 `click`、`resize` 等
2. 资源加载，如 `load`、`error` 等
3. 定时器，包括 `setInterval`、`setTimeout` 等异步任务相关回调函数添加到任务队列中（任务队列也称为消息队列）。

#### (4) JS 执行机制

1. 先执行 **执行栈中的同步任务**。
2. 异步任务（回调函数）放入任务队列中。
3. 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取 **任务队列** 中的异步任务，于是被读取的异步务结束等待状态，进入执行栈，开始执行。

![bom2](https://cdn.jsdelivr.net/gh/Hacker-C/Picture-Bed@main/JavaScript/bom2.40uo3yu1dv20.png)

举例分析：

```js
console.log(1);
document.addEventListener("click", function() {
    console.log("click");
});
setTimeout(function () {
    console.log(3);
}, 3000);
console.log(2);
```

- 若不触发点击事件，结果将依次输出 `1`、`2`、`3`；
- 若点击事件在 3 秒前触发，则依次输出 `1`、`2`、`click`、`3`
- 若点击事件在 3 秒后触发，则依次输出 `1`、`2`、`3`、`click`

#### (5) 事件循环

由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为 **事件循环（event loop）**。

![bom3](https://cdn.jsdelivr.net/gh/Hacker-C/Picture-Bed@main/JavaScript/bom3.720uz5f9vh00.png)

### -05. location 对象

#### (1)什么是 location 对象

`window` 对象给我们提供了一个 `location` 属性用于 **获取或设置窗体的URL**，并且可以用于 **解析 URL**。因为这个属性返回的是一个对象，所以我们将这个属性也称为 `location` 对象。

#### (2)URL

**统一资源定位符（Uniform Resource Locator, URL）**是互联网上标准资源的地址。互联网上的每个文件都有 一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。

 URL 的一般语法格式为：

```
格式
protocol://host[:port]/path/[?query]#fragment
举例
http://www.itcast.cn/index.html?name=andy&age=18#link
```

| 组成       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| `protocol` | 通信协议（http、ftp）                                        |
| `host`     | 主机（域名）                                                 |
| `port`     | 端口号（可选），省略时使用方案的默认端口，如http默认端口80   |
| `path`     | 路径，由零或多个 `/` 隔开的字符串，一般表示主机上的一个目录或文件地址 |
| `query`    | 参数，以键值对的形式，通过 `&` 符号分隔开                    |
| `fragment` | 片段，`#` 后面内容，常见于链接、锚点                         |

#### (3) location 对象的属性

| location对象属性    | 返回值                                   |
| ------------------- | ---------------------------------------- |
| `location.href`     | 获取或者设置 整个URL                     |
| `location.host`     | 返回主机（域名）                         |
| `location.port`     | 返回端口号，未写则返回空字符串           |
| `location.pathname` | 返回路径                                 |
| `location.search`   | 返回参数                                 |
| `location.hash`     | 返回片段，`#` 后面内容，常见于链接、锚点 |

> 重点记住：`href` 和 `search`

#### (4) location 对象的方法

| location对象方法     | 返回值                                                       |
| -------------------- | ------------------------------------------------------------ |
| `location.assign()`  | 跟 `href` 一样，可以跳转页面（也称为重定向页面），记录浏览历史，可以实现后退 |
| `location.replace()` | 替换当前页面，因为不记录浏览历史，所以不能后退页面           |
| `location.reload()`  | 重新加载页面，相当于刷新按钿或者 f5 如果参数为 `true` 强制刷新 ctrl+f5 |

```js
var btn = document.querySelector('button');
btn.addEventListener('click', function () {
    // 1.记录浏览历史，所以可以实现后退功能
     location.assign('http://www.itcast.cn');
    // 2.不记录浏览历史，所以不可以实现后退功能
     location.replace('http://www.itcast.cn');
    // 3.重新加载页面，相当于刷新按钮或者F5 如果参数为true 强制刷新ctrl+f5
     location.reload(true);
})
```

### -06. navigator 对象

`navigator` 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 `userAgent`，该属性可以返回由客 户机发送服务器的 `user-agent` 头部的值。 下面前端代码可以判断用户那个终端打开页面，实现跳转：

```js
if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) {
    window.location.href = ""; //手机
} else {
    window.location.href = ""; //电脑
}
```

### -07. history 对象

`window` 对象给我们提供了一个 `history` 对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的URL。

| `history`对象方法 | 作用                                                      |
| ----------------- | --------------------------------------------------------- |
| `back()`          | 网页地址后退功能                                          |
| `forward()`       | 前进功能                                                  |
| `go(参数)`        | 前进后退功能，参数为 `1`，前进一个页面，`-1` 后退一个页面 |

`history` 对象一般在实际开发中比较少用，但是会在一些 OA 办公系统中见到。

## PC端网页特效

> 在前面学习了JS基础、DOM 和 BOM 的基本操作后，这部分主要学习这些知识的拓展应用。

### -01.元素偏移量offset系列

#### (1) offset 概述

`offset` 翻译过来就是偏移量，我们使用 `offset` 系列相关属性可以动态的得到该元素的位置（偏移）、大小等。

- 获得元素距离带有定位父元素的位置
- 获得元素自身的大小（宽度高度）
- 注意：返回的数值都不带单位

`offset` 系列常用属性：

| offset系列属性         | 作用                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `element.offsetParent` | 返回作为该元素带有定位的父级元素，如果父级都没有定位则返回`body` |
| `element.offsetTop`    | 返回元素相对带有定位父元素上方的偏移                         |
| `element.offsetLeft`   | 返回元素相对于带有定位父元素左边框的偏移                     |
| `element.offsetWidth`  | 返回自身包括内边距、边框、内容区的宽度（返回数值不带单位）   |
| `element.offsetHeight` | 返回自身包括内边距、边框、内容区的高度（返回数值不带单位）   |

#### (2)offset与style的区别

##### 1. offset

- `offset` 可以得到任意样式表中的样式值
- `offset` 系列获得的数值是没有单位的
- `offsetWidt`h 包含 `padding+border+width`
- `offsetWidth` 等属性是只读属性，只能获取不能赋值
- **所以，我们想要获取元素大小位置，用 `offset`更合适**

##### 2. style

- `style` 只能得到行内样式表中的样式值
- `style.width` 获得的是带有单位的字符串
- `style.width` 获得不包含 `padding` 和 `border` 的值
- `style.width` 是可读写属性，可以获取也可以赋值
- **所以，我们想要给元素更改值，则需要用 `style` 改变**

#### (3)案例：获取鼠标在盒子内的坐标

##### 1. 分析

1. 我们在盒子内点击，想要得到鼠标距离盒子左右的距离。
2. 首先得到鼠标在页面中的坐标`(e.pageX, e.pageY)`
3. 其次得到盒子在页面中的距离`(box.offsetLeft,box.offsetTop)`
4. 用鼠标距离页面的坐标减去盒子在页面中的距离，得到鼠标在盒子内的坐标
5. 如果想要移动一下鼠标，就要获取最新的坐标，使用鼠标移动事件`mousemove`

##### 2. 实现代码

```js
var box = document.querySelector('.box');
box.addEventListener('mousemove', function(e) {
  var x = e.pageX - this.offsetLeft;
  var y = e.pageY - this.offsetTop;
  this.innerHTML = 'x坐标是' + x + ' y坐标是' + y;
})
```

### -02. 元素可视区 client 系列

#### (1) 定义

`client` 翻译过来就是客户端，我们使用 `client` 系列的相关属性来获取元素可视区的相关信息。通过`client` 系列的相关属性可以动态的得到该元素的边框大小、元素大小等。

| client系列属性         | 作用                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `element.clientTop`    | 返回元素上边框的大小                                         |
| `element.clientLeft`   | 返回元素左边框的大小                                         |
| `element.clientWidth`  | 返回自身包括 `padding`、内容区的宽度，不含边框，返回数值不带单位 |
| `element.clientHeight` | 返回自身包括 `padding`、内容区的高度，不含边框，返回数值不带单位 |

![client1](https://cdn.jsdelivr.net/gh/Hacker-C/Picture-Bed@main/JavaScript/client1.6bor0qa82lk0.png)

#### (2) 案例flexible.js源码分析

##### 1.立即执行函数

立即执行函数是指函数定义好后，不需要调用直接执行。即一引入 JS 文件，则该函数自动执行。

语法：`(function() {})()` 或者 `(function(){}())`

主要作用：

- 创建一个独立的作用域
- 避免了命名冲突问题

举例：

```js
(function () {console.log('hello');})(); //hello
```

可以传参数：

```js
(function (a) {console.log(a);})(10); // 10
```

##### 2. pageShow 事件

下面三种情况都会刷新页面都会触发load 事件。

1. a标签的超链接
2. F5或者刷新按钮（强制刷新）
3. 前进后退按钮

但是火狐中，有个特点，有个“往返缓存”，这个缓存中不仅保存着页面数据，还保存了 DOM 和 JavaScript 的状态；实际上是将整个页面都保存在了内存里。

所以此时后退按钮不能刷新页面。

此时可以使用 `pageshow` 事件来触发。，这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页 面中，`pageshow` 会在 `load` 事件触发后触发；根据事件对象中的 `persisted` 来判断是否是缓存中的页面触发的`pageshow` 事件，注意这个事件给 `window` 添加。

> 多个立即执行函数间要加分号 `;` 隔开。

### -03. 元素滚动 scroll 系列

#### (1)元素scroll 系列属性

`scroll` 翻译过来就是滚动的，我们使用 `scroll` 系列的相关属性可以动态的得到该元素的大小、滚动距离等。

| scroll系列属性         | 作用                                         |
| ---------------------- | -------------------------------------------- |
| `element.scrollTop`    | 返回被卷上去的上侧距离，返回数值不带单位     |
| `element.scrollLeft`   | 返回被卷上去的左侧距离，返回数值不带单位     |
| `element.scrollWidth`  | 返回自身实际宽度，不含边框，返回数值不带单位 |
| `element.scrollHeight` | 返回自身实际高度，不含边框，返回数值不带单位 |

如下图所示 ![scroll1](https://cdn.jsdelivr.net/gh/Hacker-C/Picture-Bed@main/JavaScript/scroll1.4xrvppmwt800.png)

#### (2)页面被卷去的头部

如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏 掉的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发 `onscroll` 事件。

**获取页面被卷去的头部**：

- **页面 被卷去的头部**：可以通过 `window.pageYOffset` 获得，**页面被卷去的左侧** `window.pageXOffset`
- **元素被卷去的头部**是 `element.scrollTop`，左侧 `element.scrollLeft`

#### (3) 案例：仿淘宝固定右侧侧边栏

需求：

1. 原先侧边栏是绝对定位
2. 当页面滚动到一定位置，侧边栏改为固定定位
3. 页面继续滚动，会让返回顶部显示出来

要点：

1. 需要用到页面滚动事件 `scroll` 因为是页面滚动，所以事件源是 `document`
2. 滚动到某个位置，就是判断页面被卷去的上部值。
3. 页面被卷去的头部：可以通过 `window.pageYOffset` 获得如果是被卷去的左侧 `window.pageXOffset`
4. 注意，元素被卷去的头部是 `element.scrollTop` , 如果是页面被卷去的头部则是 `window.pageYOffset`
5. 其实这个值可以通过盒子的 `offsetTop` 可以得到，如果大于等于这个值，就可以让盒子固定定位了
6. `window.scroll(x,y)`滚动窗口至文档中的特定位置。x,y坐标不跟单位

### -04. 三大系列总结

#### (1) 对比

| 三大系列大小对比      | 作用                                                         |
| --------------------- | ------------------------------------------------------------ |
| `element.offsetWidth` | 返回自身包括 `padding`、边框、内容区的宽度，返回数值不带单位 |
| `element.clientWidth` | 返回自身包括 `padding`、内容区的宽度，不含边框，返回数值不带单位 |
| `element.scrollWidth` | 返回自身实际的宽度，不含边框，返回数值不带单位               |

#### (2)主要用法

1. `offset` 系列经常用于获得元素位置 `offsetLeft`、`offsetTop`
2. `client` 经常用于获取元素大小 `clientWidth` 、`clientHeight`
3. `scroll` 经常用于获取滚动距离 `scrollTop`、`scrollLeft`
4. 注意页面滚动的距离通过 `window.pageXOffset` 获得

#### (3)mouseenter 和 mouseover 的区别

- 当鼠标移动到元素上时就会触发 `mouseenter` 事件
- 类似 `mouseover`，它们两者之间的差别是
- `mouseover` 鼠标经过自身盒子会触发，经过子盒子还会触发。`mouseenter` 只会经过自身盒子触发
- 之所以这样，就是因为 `mouseenter` 不会冒泡
- 跟 `mouseenter` 搭配鼠标离开 `mouseleave` 同样不会冒泡

### -05. 动画函数封装

#### (1)动画实现原理

核心原理：通过定时器 `setInterval()` 不断移动盒子位置。 实现步骤：

1. 获得盒子当前位置
2. 让盒子在当前位置加上 1 个移动距离
3. 利用定时器不断重复这个操作
4. 加一个结束定时器的条件
5. 注意此元素需要添加定位（`position: absolute`），才能使用 `element.style.left`

#### (2) 动画函数简单封装

注意函数需要传递 2 个参数，**动画对象和移动到的距离**。

```js
function animate(obj, target) {
    // 设置定时器
    var timer = setInterval(function () {
        if (obj.offsetLeft <= target) {
            obj.style.left = obj.offsetLeft + 1 + 'px';
        } else {
            // 清除定时器
            clearInterval(timer);
        }
    }, 30);
}
```

#### (3) 动画函数给不同元素记录不同定时器

如果多个元素都使用这个动画函数，每次都要 `var` 声明定时器。我们可以给不同的元素使用不同的定时器（自己专门用自己的定时器）。

核心原理：利用 JS 是一门动态语言，可以很方便的给当前对象添加属性。

举例

```js
// 封装动画函数
function animate(obj, target) {
    // 给不同节点对象 obj 设置定时器
    obj.timer = setInterval(function () {
        if (obj.offsetLeft <= target) {
            obj.style.left = obj.offsetLeft + 1 + 'px';
        } else {
            // 清除对象自己的定时器
            clearInterval(obj.timer);
        }
    }, 30);
}
```

#### (4) 缓动效果原理

之前讲的是匀速动画：盒子当前位置 = 盒子当前位置 + 固定值盒子当前位置=盒子当前位置+固定值

缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来
思路：

1. 让盒子每次移动的距离慢慢变小，速度就会慢慢落下来。
2. **核心算法**：每次移动的距离步长 = (目标值 - 现在的位置) / 10每次移动的距离步长=(目标值−现在的位置)/10
3. 停止的条件是：让当前盒子位置等于目标位置就停止定时器
4. 注意步长值需要取整

举例：

```js
function animate(obj, target) {
    clearInterval(obj.timer);
    obj.timer = setInterval(function () {
        // 缓冲动画核心算法
        var step = Math.ceil((target - obj.offsetLeft) / 10);
        if (obj.offsetLeft === target) {
            clearInterval(obj.timer);
        }
        obj.style.left = obj.offsetLeft + step + 'px';
    }, 30);
}
```

#### (5) 动画函数多个目标值之间移动

可以让动画函数从 `800` 移动到 `500`。
当我们点击按钮时候，判断步长是正值还是负值：

1. 如果是正值，则步长往大了取整（`Math.ceil()`）
2. 如果是负值，则步长向小了取整（`Math.floor()`）

举例：

```js
function animate(obj, target) {
    clearInterval(obj.timer);
    obj.timer = setInterval(function () {
        // 缓冲动画核心算法
        var step = target - obj.offsetLeft;
        // 左右移动步值正负处理
        step = step >= 0 ?  Math.ceil(step / 10) :  Math.floor(step / 10);
        if (obj.offsetLeft === target) {
            clearInterval(obj.timer);
        }
        obj.style.left = obj.offsetLeft + step + 'px';
    }, 30);
}
```

#### (6)动画函数添加回调函数

- **回调函数原理**：函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后， 再执行传进去的这个函数，这个过程就叫做 **回调（`callback`）**。
- **回调函数写的位置：定时器结束的位置**。

案例：

```js
// 增加回调函数形参 callback
function animate(obj, target, callback) {
    clearInterval(obj.timer);
    obj.timer = setInterval(function () {
        // 缓冲动画核心算法
        let step = target - obj.offsetLeft;
        // 左右移动步值正负处理
        step = step >= 0 ? Math.ceil(step / 10) : Math.floor(step / 10);
        if (obj.offsetLeft === target) {
            clearInterval(obj.timer);
            // 判断，回调函数 callback 存在则调用
            if (callback) {
                callback();
            }
        }
        obj.style.left = obj.offsetLeft + step + 'px';
    }, 30);
}
// 回调函数作为实参传入
animate(span, 800, function () {
    span.style.backgroundColor = 'pink';
});
```

#### (7)动画函数封装到单独JS文件里面

因为以后经常使用这个动画函数，可以单独封装到一个JS文件里面，使用的时候引用这个JS文件即可。

1. 单独新建一个 JS 文件。
2. HTML文件引入 JS 文件。

### -06. 常见网页特效案例

#### (1) 案例1：轮播图

轮播图也称为焦点图，是网页中比较常见的网页特效。

功能需求：

1. 鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮。
2. 点击右侧按钮一次，图片往左播放一张，以此类推，左侧按钮同理。
3. 图片播放的同时，下面小圆圈模块跟随一起变化。
4. 点击小圆圈，可以播放相应图片。
5. 鼠标不经过轮播图，轮播图也会自动播放图片。
6. 鼠标经过，轮播图模块，自动播放停止。

#### (2) 案例2：返回顶部

##### 1. window.scroll

滚动窗口至文档中的特定位置：

```js
window.scroll(x, y)
```

注意：里面的 `x` 和 `y` 不跟单位，直接写数字。

##### 2. 带有动画的返回顶部

1. 此时可以继续使用我们封装的动画函数
2. 只需要把所有的 `left` 相关的值改为跟页面垂直滚动距离相关就可以了
3. 页面滚动了多少，可以通过 `window.pageYOffset` 得到
4. 最后是页面滚动，使用 `window.scroll(x, y)`

##### 3. 修改后的缓存动画函数

```js
function animate(obj, target, callback) {
    clearInterval(obj.timer);
    obj.timer = setInterval(function () {
        // 缓冲动画核心算法
        var step = target - window.pageYOffset;
        step = step >= 0 ? Math.ceil(step / 10) : Math.floor(step / 10);
        if (window.pageYOffset === target) {
            clearInterval(obj.timer);
            callback && callback();
        }
        window.scroll(0, window.pageYOffset + step);
    }, 30);
}
```

调用：

```js
animate(window, 0);
```

#### (3)案例3：筋斗云

##### 1. 效果

- 鼠标经过某个小 `li`，筋斗云跟这到当前小 `li` 位置
- 鼠标离开这个小 `li`，筋斗云复原为原来的位置
- 鼠标点击了某个小 `li`，筋斗云就会留在点击这个小 `li` 的位置

##### 2. 实现

1. 利用动画函数做动画效果
2. 原先筋斗云的起始位置是 `0`
3. 鼠标经过某个小 `li`，把当前小 `li` 的 `offsetLeft` 位置做为目标值即可
4. 鼠标离开某个小 `li`，就把目标值设为 `0`
5. 如果点击了某个小 `li`，就把 `li` 当前的位置存储起来，做为筋斗云的起始位置

核心代码：

```js
var current = 0;
for (var i = 0; i < lis.length; i++) {
    // (1) 鼠标经过把当前小li 的位置做为目标值
    lis[i].addEventListener('mouseenter', function() {
        animate(cloud, this.offsetLeft);
    });
    // (2) 鼠标离开就回到起始的位置 
    lis[i].addEventListener('mouseleave', function() {
        animate(cloud, current);
    });
    // (3) 当我们鼠标点击，就把当前位置做为目标值
    lis[i].addEventListener('click', function() {
        current = this.offsetLeft;
    });
}
```

## 移动端网页特效

### -01.触屏事件

#### (1)概述

移动端浏览器兼容性较好，我们不需要考虑以前 JS 的兼容性问题，可以放心的使用原生 JS 书写效果，但是移动端也有自己独特的地方。比如**触屏事件 touch**（也称触摸事件），Android 和 IOS 都有。

touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作。

常见的触屏事件如下：

| 触屏事件     | 说明                          |
| ------------ | ----------------------------- |
| `touchstart` | 手指触摸到一个DOM元素时触发   |
| `touchmove`  | 手指在一个DOM元素上滑动时触发 |
| `touchend`   | 手指从一个DOM元素上移开时触发 |

#### (2)触摸事件对象（TouchEvent）

`TouchEvent` 是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少，等等

`touchstart`、`touchmove`、`touchend` 三个事件都会各自有事件对象。触摸事件对象重点我们看三个常见对象列表：

| 触摸列表         | 说明                                             |
| ---------------- | ------------------------------------------------ |
| `touches`        | 正在触摸屏幕的所有手指的一个列表                 |
| `targetTouches`  | 正在触摸当前DOM元素上的手指的一个列表            |
| `changedTouches` | 手指状态发生了改变的列表，从无到有，从有到无变化 |

> **因为平时我们都是给元素注册触摸事件，所以重点记住** `targetTocuhes`

#### (3)移动端拖动元素

1. ` touchstart`、`touchmove`、`touchend` 可以实现拖动元素
2.  但是拖动元素需要当前手指的坐标值 我们可以使用 `targetTouches[0] `里面的`pageX` 和 `pageY` 
3. 移动端拖动的原理： 手指移动中，计算出手指移动的距离。然后用盒子原来的位置 + 手指移动的距离
4. 手指移动的距离： 手指滑动中的位置 减去 手指刚开始触摸的位置

拖动元素三步曲：

1.  触摸元素 `touchstart`： 获取手指初始坐标，同时获得盒子原来的位置
2. 移动手指 `touchmove`： 计算手指的滑动距离，并且移动盒子
3. 离开手指 `touchend`:

> 注意： 手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动 `e.preventDefault()`

### -02.移动端常见特效

#### (1) classList 属性

`classList`属性是HTML5新增的一个属性（IE9+），返回元素的类名。该属性**用于在元素中添加，移除及切换 CSS 类**。有以下方法

- **添加类：**`element.classList.add（’类名’）`

  ```js
  focus.classList.add(‘current’);
  ```

- **移除类：**`element.classList.remove（’类名’）`

  ```js
  focus.classList.remove(‘current’);
  ```

- **切换类：**`element.classList.toggle（’类名’）`

  ```js
  focus.classList.toggle(‘current’);
  ```

> **注意以上方法里面，所有类名都不带点**

#### (2) click延时解决方案

移动端 `click` 事件会有 300ms 的延时，原因是移动端屏幕双击会缩放(double tap to zoom) 页面。

解决方案：

1.  禁用缩放。 浏览器禁用默认的双击缩放行为并且去掉 300ms 的点击延迟。

   ```html
   <meta name="viewport" content="user-scalable=no">
   ```

2. 利用`touch`事件自己封装这个事件解决 300ms 延迟。原理：

   1. 当我们手指触摸屏幕，记录当前触摸时间
   2. 当我们手指离开屏幕， 用离开的时间减去触摸的时间
   3. 如果时间小于150ms，并且没有滑动过屏幕， 那么我们就定义为点击

```js
//封装tap，解决click 300ms 延时
function tap (obj, callback) {
   var isMove = false;
   var startTime = 0; // 记录触摸时候的时间变量
   obj.addEventListener('touchstart', function (e) {
       startTime = Date.now(); // 记录触摸时间
   });
   obj.addEventListener('touchmove', function (e) {
       isMove = true; // 看看是否有滑动，有滑动算拖拽，不算点击
   });
   obj.addEventListener('touchend', function (e) {
       if (!isMove && (Date.now() - startTime) < 150) { // 如果手指触摸和离开时间小于150ms 算点击
          callback && callback(); // 执行回调函数
       }
       isMove = false; // 取反 重置
       startTime = 0;
   });
}
//调用 
 tap(div, function(){ // 执行代码 });
```

3. 使用插件。 fastclick 插件解决 300ms 延迟

### -03.移动端常用开发插件

#### (1)什么是插件

移动端要求的是快速开发，所以我们经常会借助于一些插件来帮我完成操作，那么什么是插件呢？

JS 插件是 js 文件，它遵循一定规范编写，方便程序展示效果，拥有特定功能且方便调用。如轮播图和瀑布流插件。

特点：它一般是为了解决某个问题而专门存在，其功能单一，并且比较小。

我们以前写的animate.js 也算一个最简单的插件

#### (2)插件的使用

1. 引入 js 插件文件。
2. 按照规定语法使用。

fastclick 插件解决 300ms 延迟。 使用延时

GitHub官网地址： https://github.com/ftlabs/fastclick

```js
if ('addEventListener' in document) {
   document.addEventListener('DOMContentLoaded', function() {
         FastClick.attach(document.body);
    }, false);
}
```

#### (3) Swiper 插件的使用

中文官网地址： https://www.swiper.com.cn/ 

1. 引入插件相关文件。
2.  按照规定语法使用

#### (4)其他移动端常见插件

- uperslide： http://www.superslide2.com/
-  iscroll： https://github.com/cubiq/iscroll

#### (5)插件的使用总结

1. 确认插件实现的功能
2. 去官网查看使用说明
3. 下载插件
4. 打开demo实例文件，查看需要引入的相关文件，并且引入
5. 复制demo实例文件中的结构html，样式css以及js代码

### -04.移动端常用开发框架

#### (1)框架概述

**框架，顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方案**。框架的控制权在框架本身，使用者要按照框架所规定的某种规范进行开发。

插件一般是为了解决某个问题而专门存在，其功能单一，并且比较小。

前端常用的框架有 Bootstrap、Vue、Angular、React 等。既能开发PC端，也能开发移动端

前端常用的移动端插件有 swiper、superslide、iscroll等。

- **框架： 大而全，一整套解决方案**
- **插件： 小而专一，某个功能的解决方案**

#### (2) Bootstrap

Bootstrap 是一个简洁、直观、强悍的前端开发框架，它让 web 开发更迅速、简单。它能开发PC端，也能开发移动端

Bootstrap JS插件使用步骤：

1. 引入相关js 文件
2. 复制HTML 结构
3. 修改对应样式
4. 修改相应JS 参数

## 本地存储

### -01.简介

随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案。 

**本地存储特性**

- 数据存储在用户浏览器中
- 设置、读取方便、甚至页面刷新不丢失数据
- 容量较大，`sessionStorage`约5M、`localStorage`约20M
- 只能存储字符串，可以将对象`JSON.stringify()`编码后存储

### -02. `window.sessionStorage`

1. 生命周期为关闭浏览器窗口
2. 在同一个窗口(页面)下数据可以共享
3.  以键值对的形式存储使用

#### (1)存储数据

```js
sessionStorage.setItem(key, value)
```

#### (2)获取数据

```js
sessionStorage.getItem(key)
```

#### (3)删除数据

```js
sessionStorage.removeItem(key)
```

#### (4)删除所有数据

```js
sessionStorage.clear()
```

### -02. `window.localStorage`

1. 声明周期永久生效，除非手动删除 否则关闭页面也会存在
2. 可以多窗口（页面）共享（同一浏览器可以共享）
3.  以键值对的形式存储使用

#### (1)存储数据

```js
localStorage.setItem(key, value)
```

#### (2)获取数据

```js
localStorage.getItem(key)
```

#### (3)删除数据

```js
localStorage.removeItem(key)
```

#### (4)删除所有数据

```js
localStorage.clear()
```

